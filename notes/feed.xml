<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">
	<title>My notes</title>
	<subtitle>My notes site</subtitle>
	<link rel="self" type="application/atom+xml" href="https://josephbak.github.io/notes/feed.xml"/>
  <link rel="alternate" type="text/html" href="https://josephbak.github.io/notes/"/>
  
	<updated>2025-10-14T00:00:00+00:00</updated>
	
	<id>https://josephbak.github.io/notes/feed.xml</id>
	<entry xml:lang="en">
		<title>Lowering as Graph-of-Graphs: A Structural View of MLIR and LLVM Pipelines</title>
		<published>2025-10-14T00:00:00+00:00</published>
		<updated>2025-10-14T00:00:00+00:00</updated>
		<link rel="alternate" type="text/html" href="https://josephbak.github.io/notes/mlir-graph-of-graphs-lowering/"/>
		<id>https://josephbak.github.io/notes/mlir-graph-of-graphs-lowering/</id>
    
		<content type="html" xml:base="https://josephbak.github.io/notes/mlir-graph-of-graphs-lowering/">&lt;!-- KaTeX includes (inline; requires markdown.render_unsafe = true) --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.16.10&#x2F;dist&#x2F;katex.min.css&quot;&gt;
&lt;script defer src=&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.16.10&#x2F;dist&#x2F;katex.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script defer src=&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.16.10&#x2F;dist&#x2F;contrib&#x2F;auto-render.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script&gt;
 document.addEventListener(&quot;DOMContentLoaded&quot;, function() {
 renderMathInElement(document.body, {
 delimiters: [
 {left: &quot;$$&quot;, right: &quot;$$&quot;, display: true},
 {left: &quot;\[&quot;, right: &quot;\]&quot;, display: true},
 {left: &quot;$&quot;, right: &quot;$&quot;, display: false},
 {left: &quot;\(&quot;, right: &quot;\)&quot;, display: false}
 ],
 throwOnError: false
 });
 });
&lt;&#x2F;script&gt;
&lt;p&gt;&lt;em&gt;A structural note on how the MLIR&#x2F;LLVM lowering process itself forms a higher-order computation graph — a graph of graph transformations.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;tl-dr&quot;&gt;TL;DR&lt;a class=&quot;zola-anchor&quot; href=&quot;#tl-dr&quot; aria-label=&quot;Anchor link for: tl-dr&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Every program in MLIR or LLVM IR can be represented as a &lt;strong&gt;computation graph&lt;&#x2F;strong&gt; $G = (V,E)$.&lt;&#x2F;li&gt;
&lt;li&gt;Each &lt;strong&gt;compiler pass&lt;&#x2F;strong&gt; acts as a &lt;strong&gt;graph transformation&lt;&#x2F;strong&gt; $P_i: G_{i-1} \to G_i$.&lt;&#x2F;li&gt;
&lt;li&gt;The entire &lt;strong&gt;pipeline&lt;&#x2F;strong&gt; is therefore a &lt;strong&gt;meta-graph&lt;&#x2F;strong&gt; (a directed graph whose nodes are IR graphs and edges are passes).&lt;&#x2F;li&gt;
&lt;li&gt;Conceptually, compiler lowering is a &lt;strong&gt;graph of transformations over graphs of computation&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;This interpretation connects modern compiler design with &lt;strong&gt;graph rewriting systems&lt;&#x2F;strong&gt; and &lt;strong&gt;category theory&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;1-level-0-the-ir-graph-computation&quot;&gt;1) Level-0 — The IR Graph: Computation&lt;a class=&quot;zola-anchor&quot; href=&quot;#1-level-0-the-ir-graph-computation&quot; aria-label=&quot;Anchor link for: 1-level-0-the-ir-graph-computation&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;At the base level, a program is represented as a directed graph&lt;&#x2F;p&gt;
&lt;p&gt;$$
G_0 = (V_0, E_0)
$$&lt;&#x2F;p&gt;
&lt;p&gt;where:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$V_0$: operations (e.g., &lt;code&gt;mhlo.add&lt;&#x2F;code&gt;, &lt;code&gt;mhlo.dot&lt;&#x2F;code&gt;, &lt;code&gt;linalg.matmul&lt;&#x2F;code&gt;)&lt;&#x2F;li&gt;
&lt;li&gt;$E_0$: data dependencies (SSA edges)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Example:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   %x
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    │
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ▼
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; mhlo.add
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    │
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ▼
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; mhlo.relu
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    │
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    ▼
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; mhlo.return
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is the &lt;strong&gt;program graph&lt;&#x2F;strong&gt;—it captures what is computed, not how it is lowered.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;2-level-1-the-pass-graph-local-rewrite-structure&quot;&gt;2) Level-1 — The Pass Graph: Local Rewrite Structure&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-level-1-the-pass-graph-local-rewrite-structure&quot; aria-label=&quot;Anchor link for: 2-level-1-the-pass-graph-local-rewrite-structure&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;Each compiler pass applies a set of rewrite rules to subgraphs of the IR.&lt;&#x2F;p&gt;
&lt;p&gt;Formally:
$$
P = (V_P, E_P)
$$&lt;&#x2F;p&gt;
&lt;p&gt;where:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$V_P$: rewrite rules (pattern + replacement)&lt;&#x2F;li&gt;
&lt;li&gt;$E_P$: dependencies among rules (e.g., one rewrite must precede another)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Example (MHLO → Linalg lowering):&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; Pass: mhlo → linalg
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; ───────────────────
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; mhlo.add  ───→  linalg.add
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; mhlo.relu ───→  linalg.max
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This graph represents the &lt;strong&gt;local transformation flow&lt;&#x2F;strong&gt; within a single pass.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;3-level-2-the-pipeline-meta-graph-graphs-of-graphs&quot;&gt;3) Level-2 — The Pipeline Meta-Graph: Graphs of Graphs&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-level-2-the-pipeline-meta-graph-graphs-of-graphs&quot; aria-label=&quot;Anchor link for: 3-level-2-the-pipeline-meta-graph-graphs-of-graphs&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;Each compiler pass maps one complete IR graph to another:&lt;&#x2F;p&gt;
&lt;p&gt;$$
P_i : G_{i-1} \rightarrow G_i
$$&lt;&#x2F;p&gt;
&lt;p&gt;Hence the overall compiler pipeline can be viewed as a &lt;strong&gt;meta-graph&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\mathcal{G} = (\mathcal{V}, \mathcal{E}), \quad
\mathcal{V} = {G_0, G_1, \ldots, G_n}, \quad
\mathcal{E} = {(G_{i-1}, G_i) \mid G_i = P_i(G_{i-1})}
$$&lt;&#x2F;p&gt;
&lt;p&gt;Example pipeline:&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;[MHLO Graph] --(P1)--&amp;gt; [Linalg Graph] --(P2)--&amp;gt; [LLVM Graph]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;Nodes ($\mathcal{V}$): IR snapshots (entire program graphs)&lt;&#x2F;li&gt;
&lt;li&gt;Edges ($\mathcal{E}$): passes (transformations)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;The meta-graph is &lt;strong&gt;directed and acyclic&lt;&#x2F;strong&gt;, since lowering moves from high-level to low-level representations.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;4-hierarchy-summary&quot;&gt;4) Hierarchy Summary&lt;a class=&quot;zola-anchor&quot; href=&quot;#4-hierarchy-summary&quot; aria-label=&quot;Anchor link for: 4-hierarchy-summary&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style=&quot;text-align: left&quot;&gt;Level&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: left&quot;&gt;Nodes&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: left&quot;&gt;Edges&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: left&quot;&gt;Meaning&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;0: IR Graph&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Operations&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Dataflow&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;The computation itself&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;1: Pass Graph&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Rewrite rules&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Rule dependencies&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Local transformations&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;2: Pipeline Meta-Graph&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;IR snapshots&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Passes between IRs&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;The full lowering pipeline&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Each higher level acts &lt;strong&gt;on&lt;&#x2F;strong&gt; the level beneath it.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;5-category-theoretic-view&quot;&gt;5) Category-Theoretic View&lt;a class=&quot;zola-anchor&quot; href=&quot;#5-category-theoretic-view&quot; aria-label=&quot;Anchor link for: 5-category-theoretic-view&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;Define a category $\mathcal{C}$ whose objects are IR graphs and whose morphisms are passes:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\text{Obj}(\mathcal{C}) = {G_i}, \quad
\text{Mor}(\mathcal{C}) = {P_i: G_{i-1} \to G_i}
$$&lt;&#x2F;p&gt;
&lt;p&gt;Then a lowering pipeline is a &lt;strong&gt;composition of morphisms&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;$$
G_0 \xrightarrow{P_1} G_1 \xrightarrow{P_2} G_2 \xrightarrow{P_3} \cdots \xrightarrow{P_n} G_n
$$&lt;&#x2F;p&gt;
&lt;p&gt;A compiler can thus be interpreted as a &lt;strong&gt;functor&lt;&#x2F;strong&gt; between categories of graphs, preserving semantic structure through successive transformations.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;6-ascii-visualization&quot;&gt;6) ASCII Visualization&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-ascii-visualization&quot; aria-label=&quot;Anchor link for: 6-ascii-visualization&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;LEVEL 2: Meta-Graph (Pipeline)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;──────────────────────────────
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   [G0: MHLO] ──P1──&amp;gt; [G1: Linalg] ──P2──&amp;gt; [G2: LLVM]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;          │                  │                    │
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;          ▼                  ▼                    ▼
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;LEVEL 1: Pass Graphs
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;──────────────────────────────
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   mhlo.add→linalg.add   linalg.matmul→llvm.call
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   mhlo.relu→linalg.max  ...
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;          │                  │
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;          ▼                  ▼
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;LEVEL 0: IR Graphs
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;──────────────────────────────
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   mhlo.add ─→ mhlo.relu → return
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   linalg.add ─→ linalg.max → return
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   llvm.add ─→ llvm.ret
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;7-relation-to-established-frameworks&quot;&gt;7) Relation to Established Frameworks&lt;a class=&quot;zola-anchor&quot; href=&quot;#7-relation-to-established-frameworks&quot; aria-label=&quot;Anchor link for: 7-relation-to-established-frameworks&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;The “graph-of-graphs” viewpoint exists under several names across different research areas:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th style=&quot;text-align: left&quot;&gt;Domain&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: left&quot;&gt;Equivalent Concept&lt;&#x2F;th&gt;&lt;th style=&quot;text-align: left&quot;&gt;Reference&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;Compiler theory&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Pass pipelines as graph transformations&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;LLVM &#x2F; MLIR design docs&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;Graph rewriting systems&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Double-pushout (DPO) formalism&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Ehrig et al., &lt;em&gt;Graph Grammars&lt;&#x2F;em&gt;, 1999&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;Category theory&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Functors between graph categories&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Carette et al., &lt;em&gt;Compiling to Categories&lt;&#x2F;em&gt;, 2010&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;Equality saturation&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;DAG of equivalent graphs&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Willsey et al., &lt;em&gt;egg&lt;&#x2F;em&gt;, 2021&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;Verified compilation&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;IR equivalence proofs&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Lopes et al., &lt;em&gt;Alive2&lt;&#x2F;em&gt;, 2020&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td style=&quot;text-align: left&quot;&gt;Meta-scheduling&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Compiler DAG search&lt;&#x2F;td&gt;&lt;td style=&quot;text-align: left&quot;&gt;Chen et al., &lt;em&gt;TVM Unity&lt;&#x2F;em&gt;, 2023&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;8-selected-references&quot;&gt;8) Selected References&lt;a class=&quot;zola-anchor&quot; href=&quot;#8-selected-references&quot; aria-label=&quot;Anchor link for: 8-selected-references&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;C. Lattner et al.&lt;&#x2F;strong&gt;, &lt;em&gt;MLIR: A Compiler Infrastructure for the End of Moore’s Law&lt;&#x2F;em&gt;, arXiv:2002.11054 (2021).&lt;br &#x2F;&gt;
Defines the dialect + pass architecture; each dialect transition corresponds to a graph morphism.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;H. Ehrig et al.&lt;&#x2F;strong&gt;, &lt;em&gt;Handbook of Graph Grammars and Computing by Graph Transformation&lt;&#x2F;em&gt;, World Scientific (1999).&lt;br &#x2F;&gt;
Establishes the double-pushout formalism used to describe structured graph rewriting.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;J. Willsey et al.&lt;&#x2F;strong&gt;, &lt;em&gt;egg: Fast and Extensible Equality Saturation&lt;&#x2F;em&gt;, PLDI (2021).&lt;br &#x2F;&gt;
Models optimization as the saturation of a DAG of equivalent program graphs.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;N. Lopes et al.&lt;&#x2F;strong&gt;, &lt;em&gt;Alive2: Bounded Translation Validation for LLVM&lt;&#x2F;em&gt;, arXiv:2004.04344.&lt;br &#x2F;&gt;
Proves semantic equivalence between IR transformations, effectively linking graphs $G_i$ and $G_{i+1}$.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;O. Kiselyov, J. Carette, C. Shan&lt;&#x2F;strong&gt;, &lt;em&gt;Compiling to Categories&lt;&#x2F;em&gt;, ICFP (2010).&lt;br &#x2F;&gt;
Provides categorical semantics for compilation as functor composition.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;T. Chen et al.&lt;&#x2F;strong&gt;, &lt;em&gt;TVM: End-to-End Optimization Stack for Deep Learning&lt;&#x2F;em&gt;, OSDI (2018).&lt;br &#x2F;&gt;
Represents compiler pass pipelines as meta-graphs for automated search and scheduling.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;9-takeaway&quot;&gt;9) Takeaway&lt;a class=&quot;zola-anchor&quot; href=&quot;#9-takeaway&quot; aria-label=&quot;Anchor link for: 9-takeaway&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;Lowering in MLIR&#x2F;LLVM is not a simple sequence of textual transformations.&lt;br &#x2F;&gt;
It is a &lt;strong&gt;hierarchical system of graph transformations&lt;&#x2F;strong&gt;, where:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\mathcal{G} : G_0 \xrightarrow{P_1} G_1 \xrightarrow{P_2} \cdots \xrightarrow{P_n} G_n
$$&lt;&#x2F;p&gt;
&lt;p&gt;Each $G_i$ is an IR graph (computation), and each $P_i$ is a morphism (pass).&lt;br &#x2F;&gt;
This structure unifies compiler pipelines, graph rewriting systems, and categorical reasoning into a single framework for understanding how complex program transformations can be represented, optimized, and verified.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;Author:&lt;&#x2F;strong&gt; Joseph Bak&lt;br &#x2F;&gt;
&lt;strong&gt;Date:&lt;&#x2F;strong&gt; 2025-10-14&lt;br &#x2F;&gt;
&lt;strong&gt;Keywords:&lt;&#x2F;strong&gt; MLIR, LLVM, Compiler Passes, Graph Transformation, Category Theory&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Memory Alignment and Hardware Constraints in C++</title>
		<published>2025-10-13T00:00:00+00:00</published>
		<updated>2025-10-13T00:00:00+00:00</updated>
		<link rel="alternate" type="text/html" href="https://josephbak.github.io/notes/memory-alignment-hardware-cpp/"/>
		<id>https://josephbak.github.io/notes/memory-alignment-hardware-cpp/</id>
    
		<content type="html" xml:base="https://josephbak.github.io/notes/memory-alignment-hardware-cpp/">&lt;!-- KaTeX includes (inline; requires markdown.render_unsafe = true) --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.16.10&#x2F;dist&#x2F;katex.min.css&quot;&gt;
&lt;script defer src=&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.16.10&#x2F;dist&#x2F;katex.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script defer src=&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.16.10&#x2F;dist&#x2F;contrib&#x2F;auto-render.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script&gt;
 document.addEventListener(&quot;DOMContentLoaded&quot;, function() {
 renderMathInElement(document.body, {
 delimiters: [
 {left: &quot;$$&quot;, right: &quot;$$&quot;, display: true},
 {left: &quot;\\[&quot;, right: &quot;\\]&quot;, display: true},
 {left: &quot;$&quot;, right: &quot;$&quot;, display: false},
 {left: &quot;\\(&quot;, right: &quot;\\)&quot;, display: false}
 ],
 throwOnError: false
 });
 });
&lt;&#x2F;script&gt;
&lt;h2 id=&quot;overview&quot;&gt;Overview&lt;a class=&quot;zola-anchor&quot; href=&quot;#overview&quot; aria-label=&quot;Anchor link for: overview&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;This note presents a structured view of how memory alignment and hardware-level constraints interact with the C++ object model and compiler guarantees. It connects the requirements of modern hardware architectures with language-level semantics.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;memory-model&quot;&gt;Memory Model&lt;a class=&quot;zola-anchor&quot; href=&quot;#memory-model&quot; aria-label=&quot;Anchor link for: memory-model&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;C++ programs operate in a virtual memory space divided into regions for &lt;strong&gt;code&lt;&#x2F;strong&gt;, &lt;strong&gt;static data&lt;&#x2F;strong&gt;, &lt;strong&gt;stack&lt;&#x2F;strong&gt;, and &lt;strong&gt;heap&lt;&#x2F;strong&gt;. Dynamic allocation (&lt;code&gt;new&lt;&#x2F;code&gt;, &lt;code&gt;malloc&lt;&#x2F;code&gt;) reserves space on the heap, returning a pointer satisfying platform alignment guarantees.&lt;&#x2F;p&gt;
&lt;p&gt;Each allocation unit is defined in &lt;strong&gt;bytes&lt;&#x2F;strong&gt;. For example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp z-code&quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c&quot;&gt;unsigned&lt;&#x2F;span&gt; &lt;span class=&quot;z-storage z-type z-c&quot;&gt;char&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-c++&quot;&gt;*&lt;&#x2F;span&gt; buffer &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;new&lt;&#x2F;span&gt; &lt;span class=&quot;z-storage z-type z-c&quot;&gt;unsigned&lt;&#x2F;span&gt; &lt;span class=&quot;z-storage z-type z-c&quot;&gt;char&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-brackets z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-brackets z-begin z-c++&quot;&gt;[&lt;&#x2F;span&gt;&lt;span class=&quot;z-constant z-numeric z-integer z-decimal z-c++&quot;&gt;1024&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-brackets z-end z-c++&quot;&gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;The returned address obeys &lt;code&gt;alignof(std::max_align_t)&lt;&#x2F;code&gt;, typically 8 or 16 bytes on 64-bit systems.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;alignment-definition&quot;&gt;Alignment Definition&lt;a class=&quot;zola-anchor&quot; href=&quot;#alignment-definition&quot; aria-label=&quot;Anchor link for: alignment-definition&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;Let an address $ A $ and alignment $ k \in \mathbb{N} $.&lt;br &#x2F;&gt;
$ A $ is &lt;em&gt;k-aligned&lt;&#x2F;em&gt; if and only if&lt;&#x2F;p&gt;
&lt;p&gt;$$
A \bmod k = 0.
$$&lt;&#x2F;p&gt;
&lt;p&gt;Alignment ensures that the address of an object satisfies the boundary constraints required by the underlying hardware.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;hardware-considerations&quot;&gt;Hardware Considerations&lt;a class=&quot;zola-anchor&quot; href=&quot;#hardware-considerations&quot; aria-label=&quot;Anchor link for: hardware-considerations&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;Processors read and write memory through buses that operate on fixed-size chunks. These transfer units determine the natural alignment requirements.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Level&lt;&#x2F;th&gt;&lt;th&gt;Typical Width&lt;&#x2F;th&gt;&lt;th&gt;Function&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Register&lt;&#x2F;td&gt;&lt;td&gt;8–64 B&lt;&#x2F;td&gt;&lt;td&gt;Data path width for arithmetic units&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Bus Transaction&lt;&#x2F;td&gt;&lt;td&gt;8–16 B&lt;&#x2F;td&gt;&lt;td&gt;Transfer width between cache and memory&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Cache Line&lt;&#x2F;td&gt;&lt;td&gt;64 B&lt;&#x2F;td&gt;&lt;td&gt;Unit of cache coherence&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Page&lt;&#x2F;td&gt;&lt;td&gt;4 KiB&lt;&#x2F;td&gt;&lt;td&gt;Virtual memory mapping granularity&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;If an object crosses one of these boundaries, multiple transfers or traps may occur.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;misalignment&quot;&gt;Misalignment&lt;a class=&quot;zola-anchor&quot; href=&quot;#misalignment&quot; aria-label=&quot;Anchor link for: misalignment&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;A misaligned access occurs when the address of a load or store does not satisfy its alignment. Its effect is architecture-dependent.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Architecture&lt;&#x2F;th&gt;&lt;th&gt;Behavior&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;x86-64&lt;&#x2F;td&gt;&lt;td&gt;Permitted, slower due to split transactions&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;ARM64&lt;&#x2F;td&gt;&lt;td&gt;Traps (&lt;code&gt;SIGBUS&lt;&#x2F;code&gt;)&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;RISC-V&lt;&#x2F;td&gt;&lt;td&gt;Optional trap or emulation&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Aligned access guarantees that a load&#x2F;store fits entirely within one bus transaction.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;c-language-rules&quot;&gt;C++ Language Rules&lt;a class=&quot;zola-anchor&quot; href=&quot;#c-language-rules&quot; aria-label=&quot;Anchor link for: c-language-rules&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;C++ enforces that every object’s address satisfies its alignment requirement:&lt;&#x2F;p&gt;
&lt;p&gt;$$
\text{address} \bmod \text{alignof}(T) = 0.
$$&lt;&#x2F;p&gt;
&lt;p&gt;The alignment requirement ( \text{alignof}(T) ) is a compile-time constant depending on the target ABI (Application Binary Interface).&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Type&lt;&#x2F;th&gt;&lt;th&gt;&lt;code&gt;sizeof(T)&lt;&#x2F;code&gt;&lt;&#x2F;th&gt;&lt;th&gt;&lt;code&gt;alignof(T)&lt;&#x2F;code&gt;&lt;&#x2F;th&gt;&lt;th&gt;Notes&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;char&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;1&lt;&#x2F;td&gt;&lt;td&gt;Always aligned&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;int&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;4&lt;&#x2F;td&gt;&lt;td&gt;Matches word size&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;double&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;Matches bus width&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;struct { char c; double d; }&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;16&lt;&#x2F;td&gt;&lt;td&gt;8&lt;&#x2F;td&gt;&lt;td&gt;Padding inserted&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;alignas(64) float v[8];&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;32&lt;&#x2F;td&gt;&lt;td&gt;64&lt;&#x2F;td&gt;&lt;td&gt;Manual over-alignment&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;over-alignment&quot;&gt;Over-Alignment&lt;a class=&quot;zola-anchor&quot; href=&quot;#over-alignment&quot; aria-label=&quot;Anchor link for: over-alignment&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;Manual over-alignment is declared using &lt;code&gt;alignas(N)&lt;&#x2F;code&gt;. It enforces that the object’s address is a multiple of $ N $. Example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp z-code&quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c++&quot;&gt;struct&lt;&#x2F;span&gt; &lt;span class=&quot;z-storage z-modifier z-c++&quot;&gt;alignas&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-constant z-numeric z-integer z-decimal z-c++&quot;&gt;64&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-struct z-c++&quot;&gt;Vec4&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt; &lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-storage z-type z-c&quot;&gt;float&lt;&#x2F;span&gt; data&lt;span class=&quot;z-meta z-brackets z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-brackets z-begin z-c++&quot;&gt;[&lt;&#x2F;span&gt;&lt;span class=&quot;z-constant z-numeric z-integer z-decimal z-c++&quot;&gt;4&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-brackets z-end z-c++&quot;&gt;]&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;motivation&quot;&gt;Motivation&lt;a class=&quot;zola-anchor&quot; href=&quot;#motivation&quot; aria-label=&quot;Anchor link for: motivation&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;SIMD (Single Instruction Multiple Data) operations (AVX&#x2F;AVX-512)&lt;&#x2F;li&gt;
&lt;li&gt;Cache-line isolation in concurrent programs&lt;&#x2F;li&gt;
&lt;li&gt;DMA and accelerator interfaces requiring aligned buffers&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;If the requested alignment exceeds hardware capability, the compiler inserts sufficient padding to maintain correctness. This is a compile-time guarantee; performance behavior depends on the target architecture.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;relationship-between-size-and-alignment&quot;&gt;Relationship Between Size and Alignment&lt;a class=&quot;zola-anchor&quot; href=&quot;#relationship-between-size-and-alignment&quot; aria-label=&quot;Anchor link for: relationship-between-size-and-alignment&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;$$
\text{alignof}(T) \leq \text{sizeof}(T).
$$&lt;&#x2F;p&gt;
&lt;p&gt;Equality is common for primitive types. Structs and arrays may have $ \text{alignof}(T) &amp;lt; \text{sizeof}(T) $ due to internal padding. The C++ standard only enforces address correctness, not divisibility between size and alignment.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;misalignment-visualization&quot;&gt;Misalignment Visualization&lt;a class=&quot;zola-anchor&quot; href=&quot;#misalignment-visualization&quot; aria-label=&quot;Anchor link for: misalignment-visualization&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;proper-alignment-8-byte-double&quot;&gt;Proper Alignment (8-byte &lt;code&gt;double&lt;&#x2F;code&gt;)&lt;a class=&quot;zola-anchor&quot; href=&quot;#proper-alignment-8-byte-double&quot; aria-label=&quot;Anchor link for: proper-alignment-8-byte-double&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Bus boundary: ─────────┬────────┬────────
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;                       0x1000   0x1008   0x1010
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Aligned: [0x1008–0x100F] → one 8B transaction
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;misalignment-starts-at-0x100a&quot;&gt;Misalignment (starts at 0x100A)&lt;a class=&quot;zola-anchor&quot; href=&quot;#misalignment-starts-at-0x100a&quot; aria-label=&quot;Anchor link for: misalignment-starts-at-0x100a&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Bus boundary: ─────────┬────────┬────────
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;                       0x1000   0x1008   0x1010
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Misaligned: [0x100A–0x1011] → spans two transactions
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;byte-aligned-char&quot;&gt;Byte-Aligned (&lt;code&gt;char&lt;&#x2F;code&gt;)&lt;a class=&quot;zola-anchor&quot; href=&quot;#byte-aligned-char&quot; aria-label=&quot;Anchor link for: byte-aligned-char&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;No restriction: alignment = 1
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;key-properties&quot;&gt;Key Properties&lt;a class=&quot;zola-anchor&quot; href=&quot;#key-properties&quot; aria-label=&quot;Anchor link for: key-properties&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Concept&lt;&#x2F;th&gt;&lt;th&gt;Definition&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Alignment&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Boundary constraint on object address.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Size&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Number of bytes occupied by the object.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Natural alignment&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Alignment chosen automatically by the compiler.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Over-alignment&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;User-specified stronger boundary constraint.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Misalignment&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Address violating required boundary; undefined behavior.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Hardware constraint&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;The compiler never enforces alignment stricter than hardware support.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;summary&quot;&gt;Summary&lt;a class=&quot;zola-anchor&quot; href=&quot;#summary&quot; aria-label=&quot;Anchor link for: summary&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;Alignment guarantees that memory accesses conform to hardware transfer boundaries.&lt;&#x2F;li&gt;
&lt;li&gt;Misaligned loads or stores can incur penalties or hardware traps.&lt;&#x2F;li&gt;
&lt;li&gt;$ \text{alignof}(T) $ defines the minimum alignment for a type.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;alignas(N)&lt;&#x2F;code&gt; allows manual over-alignment beyond natural alignment.&lt;&#x2F;li&gt;
&lt;li&gt;The compiler ensures $\text{alignof}(T) \leq \text{hardware_max_alignment}$.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;em&gt;This document provides a compact reference linking hardware design, compiler layout rules, and C++ alignment guarantees.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Speculative Duplication and Cost Modeling in MLIR</title>
		<published>2025-10-06T00:00:00+00:00</published>
		<updated>2025-10-07T00:00:00+00:00</updated>
		<link rel="alternate" type="text/html" href="https://josephbak.github.io/notes/mlir-speculative-duplication-cost-model/"/>
		<id>https://josephbak.github.io/notes/mlir-speculative-duplication-cost-model/</id>
    
		<content type="html" xml:base="https://josephbak.github.io/notes/mlir-speculative-duplication-cost-model/">&lt;!-- KaTeX includes (inline; requires markdown.render_unsafe = true) --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.16.10&#x2F;dist&#x2F;katex.min.css&quot;&gt;
&lt;script defer src=&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.16.10&#x2F;dist&#x2F;katex.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script defer src=&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.16.10&#x2F;dist&#x2F;contrib&#x2F;auto-render.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script&gt;
 document.addEventListener(&quot;DOMContentLoaded&quot;, function() {
 renderMathInElement(document.body, {
 delimiters: [
 {left: &quot;$$&quot;, right: &quot;$$&quot;, display: true},
 {left: &quot;\\[&quot;, right: &quot;\\]&quot;, display: true},
 {left: &quot;$&quot;, right: &quot;$&quot;, display: false},
 {left: &quot;\\(&quot;, right: &quot;\\)&quot;, display: false}
 ],
 throwOnError: false
 });
 });
&lt;&#x2F;script&gt;
&lt;h2 id=&quot;1-overview&quot;&gt;1. Overview&lt;a class=&quot;zola-anchor&quot; href=&quot;#1-overview&quot; aria-label=&quot;Anchor link for: 1-overview&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Speculative duplication&lt;&#x2F;strong&gt; duplicates part of a computation—intentionally—to unlock a more profitable transformation (e.g., fusion or vectorization) on a &lt;em&gt;hot path&lt;&#x2F;em&gt;, guided by a &lt;strong&gt;cost model&lt;&#x2F;strong&gt;. In MLIR (Multi-Level Intermediate Representation), a canonical example is enabling &lt;strong&gt;FMA (Fused Multiply-Add)&lt;&#x2F;strong&gt; contraction when a producer operation has multiple consumers.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;2-running-example-floating-point&quot;&gt;2. Running Example (Floating-Point)&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-running-example-floating-point&quot; aria-label=&quot;Anchor link for: 2-running-example-floating-point&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;baseline-ir-intermediate-representation&quot;&gt;Baseline IR (Intermediate Representation)&lt;a class=&quot;zola-anchor&quot; href=&quot;#baseline-ir-intermediate-representation&quot; aria-label=&quot;Anchor link for: baseline-ir-intermediate-representation&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;mlir&quot; class=&quot;language-mlir z-code&quot;&gt;&lt;code class=&quot;language-mlir&quot; data-lang=&quot;mlir&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;%y   = arith.mulf %x, %c1
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;%tmp = arith.subf %y, %c3
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;%z   = arith.addf %y, %c2
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;We would like to contract &lt;code&gt;%y = x*c1&lt;&#x2F;code&gt; and the &lt;code&gt;addf&lt;&#x2F;code&gt; into a single &lt;code&gt;arith.fma %x, %c1, %c2&lt;&#x2F;code&gt; for &lt;code&gt;%z&lt;&#x2F;code&gt;.&lt;br &#x2F;&gt;
However, &lt;code&gt;%y&lt;&#x2F;code&gt; has multiple uses (&lt;code&gt;%tmp&lt;&#x2F;code&gt; and &lt;code&gt;%z&lt;&#x2F;code&gt;), so replacing &lt;code&gt;%y&lt;&#x2F;code&gt; would change &lt;code&gt;%tmp&lt;&#x2F;code&gt;’s semantics—&lt;strong&gt;illegal under SSA (Static Single Assignment)&lt;&#x2F;strong&gt;.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;speculative-duplication-plan&quot;&gt;Speculative Duplication Plan&lt;a class=&quot;zola-anchor&quot; href=&quot;#speculative-duplication-plan&quot; aria-label=&quot;Anchor link for: speculative-duplication-plan&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;mlir&quot; class=&quot;language-mlir z-code&quot;&gt;&lt;code class=&quot;language-mlir&quot; data-lang=&quot;mlir&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;%y   = arith.mulf %x, %c1        &#x2F;&#x2F; kept for %tmp
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;%z   = arith.fma  %x, %c1, %c2   &#x2F;&#x2F; duplicate multiply inside fma
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;%tmp = arith.subf %y, %c3
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;Correctness is preserved (each consumer gets the right value).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;%z&lt;&#x2F;code&gt;’s path benefits from FMA’s shorter dependency chain.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;3-legality-preconditions-floating-point&quot;&gt;3. Legality Preconditions (Floating-Point)&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-legality-preconditions-floating-point&quot; aria-label=&quot;Anchor link for: 3-legality-preconditions-floating-point&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Contraction allowed:&lt;&#x2F;strong&gt; &lt;code&gt;arith.fastmath&lt;&#x2F;code&gt; must include &lt;code&gt;contract&lt;&#x2F;code&gt;; otherwise &lt;code&gt;mulf+addf → fma&lt;&#x2F;code&gt; is not IEEE (Institute of Electrical and Electronics Engineers)-legal (two roundings vs one).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;No side effects&lt;&#x2F;strong&gt; between producer and consumer.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Target must support real FMA&lt;&#x2F;strong&gt;; otherwise the rewrite regresses to &lt;code&gt;mul+add&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Examples:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;mlir&quot; class=&quot;language-mlir z-code&quot;&gt;&lt;code class=&quot;language-mlir&quot; data-lang=&quot;mlir&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;%z = arith.addf %y, %c2 {fastmath = [contract]}
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;func.func @f() attributes { arith.fastmath = [contract, reassoc] } { ... }
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;4-why-the-naive-total-work-view-fails&quot;&gt;4. Why the Naive “Total Work” View Fails&lt;a class=&quot;zola-anchor&quot; href=&quot;#4-why-the-naive-total-work-view-fails&quot; aria-label=&quot;Anchor link for: 4-why-the-naive-total-work-view-fails&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;A naive comparison sums operation costs:&lt;&#x2F;p&gt;
&lt;p&gt;$$
C_{add} &amp;gt; C_{fma} + P_{dup},
$$&lt;&#x2F;p&gt;
&lt;p&gt;which seems impossible because usually $C_{fma} \ge C_{add}$.&lt;br &#x2F;&gt;
That view assumes all work is serialized—counting every instruction as if they block each other.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;what-actually-matters&quot;&gt;What Actually Matters&lt;a class=&quot;zola-anchor&quot; href=&quot;#what-actually-matters&quot; aria-label=&quot;Anchor link for: what-actually-matters&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;Only the &lt;strong&gt;critical-path latency&lt;&#x2F;strong&gt; to produce &lt;code&gt;%z&lt;&#x2F;code&gt; affects performance.&lt;br &#x2F;&gt;
After duplication, the extra multiply for &lt;code&gt;%tmp&lt;&#x2F;code&gt; is &lt;strong&gt;independent&lt;&#x2F;strong&gt; of &lt;code&gt;%z&lt;&#x2F;code&gt;’s computation—it runs on another path or execution unit. Its cost should not be counted serially.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;5-path-aware-model&quot;&gt;5. Path-Aware Model&lt;a class=&quot;zola-anchor&quot; href=&quot;#5-path-aware-model&quot; aria-label=&quot;Anchor link for: 5-path-aware-model&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;Let $L_{op}$ denote latency (or an effective throughput proxy) for an operation on the &lt;code&gt;%z&lt;&#x2F;code&gt; path.&lt;&#x2F;p&gt;
&lt;p&gt;Baseline (no duplication): critical path to &lt;code&gt;%z&lt;&#x2F;code&gt; is &lt;code&gt;mulf → addf&lt;&#x2F;code&gt;,
$$
L_{baseline} = L_{mul} + L_{add}.
$$&lt;&#x2F;p&gt;
&lt;p&gt;With speculative duplication: critical path to &lt;code&gt;%z&lt;&#x2F;code&gt; is &lt;code&gt;fma&lt;&#x2F;code&gt; plus any path penalty,
$$
L_{dup} = L_{fma} + P_{dup, path}.
$$&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Profitability condition (latency-bound):&lt;&#x2F;strong&gt;
$$
\boxed{L_{mul} + L_{add} &amp;gt; L_{fma} + P_{dup, path}}
$$&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$P_{dup, path}$ = penalty that actually affects &lt;code&gt;%z&lt;&#x2F;code&gt;’s schedule (e.g., spill caused by higher pressure).&lt;&#x2F;li&gt;
&lt;li&gt;The multiply for &lt;code&gt;%tmp&lt;&#x2F;code&gt; exists in both cases and is off &lt;code&gt;%z&lt;&#x2F;code&gt;’s path; it should not be added to &lt;code&gt;%z&lt;&#x2F;code&gt;’s serial latency.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;6-visual-intuition-for-path-latency&quot;&gt;6. Visual Intuition for Path Latency&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-visual-intuition-for-path-latency&quot; aria-label=&quot;Anchor link for: 6-visual-intuition-for-path-latency&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;a-baseline-sequential-dependency-chain&quot;&gt;(a) Baseline — sequential dependency chain&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-baseline-sequential-dependency-chain&quot; aria-label=&quot;Anchor link for: a-baseline-sequential-dependency-chain&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;        c1       c2
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;         │        │
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;x ───▶ mulf ───▶ addf ───▶ z
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%z&lt;&#x2F;code&gt; depends on both &lt;code&gt;mulf&lt;&#x2F;code&gt; and &lt;code&gt;addf&lt;&#x2F;code&gt; sequentially.&lt;&#x2F;li&gt;
&lt;li&gt;Latency to produce &lt;code&gt;%z&lt;&#x2F;code&gt;: &lt;strong&gt;L_mul + L_add&lt;&#x2F;strong&gt; (fully serial).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;b-after-speculative-duplication-independent-paths&quot;&gt;(b) After speculative duplication — independent paths&lt;a class=&quot;zola-anchor&quot; href=&quot;#b-after-speculative-duplication-independent-paths&quot; aria-label=&quot;Anchor link for: b-after-speculative-duplication-independent-paths&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;            ┌──────────▶ subi ───▶ tmp
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;x ──▶ mulf ─┘
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; │
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; └──────────▶ fma  ───▶ z
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;%z&lt;&#x2F;code&gt; now depends only on &lt;code&gt;fma&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;%tmp&lt;&#x2F;code&gt; depends on the old &lt;code&gt;mulf&lt;&#x2F;code&gt; (runs in parallel).&lt;&#x2F;li&gt;
&lt;li&gt;Latency to produce &lt;code&gt;%z&lt;&#x2F;code&gt;: &lt;strong&gt;L_fma + P_dup,path&lt;&#x2F;strong&gt;, which is much shorter.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;c-timing-timeline&quot;&gt;(c) Timing timeline&lt;a class=&quot;zola-anchor&quot; href=&quot;#c-timing-timeline&quot; aria-label=&quot;Anchor link for: c-timing-timeline&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Baseline:
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Time →  [ mulf ][ addf ] → z ready at cycle 8
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;With duplication:
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Time →  [ mulf ][ subi ]         → tmp ready at 8
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;         [ fma ]                 → z ready at 4
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;More total instructions executed overall.&lt;&#x2F;li&gt;
&lt;li&gt;But &lt;code&gt;%z&lt;&#x2F;code&gt; finishes earlier, shortening the critical path.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;d-concept-summary&quot;&gt;(d) Concept summary&lt;a class=&quot;zola-anchor&quot; href=&quot;#d-concept-summary&quot; aria-label=&quot;Anchor link for: d-concept-summary&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;View&lt;&#x2F;th&gt;&lt;th&gt;Measures&lt;&#x2F;th&gt;&lt;th&gt;&lt;code&gt;%z&lt;&#x2F;code&gt; ready time&lt;&#x2F;th&gt;&lt;th&gt;Misleading?&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Total work&lt;&#x2F;td&gt;&lt;td&gt;Counts all instructions&lt;&#x2F;td&gt;&lt;td&gt;Same or higher&lt;&#x2F;td&gt;&lt;td&gt;Yes — ignores parallelism&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Path latency&lt;&#x2F;td&gt;&lt;td&gt;Longest dependency chain to &lt;code&gt;%z&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Lower&lt;&#x2F;td&gt;&lt;td&gt;Correct&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;7-typical-numbers-fp32&quot;&gt;7. Typical Numbers (FP32)&lt;a class=&quot;zola-anchor&quot; href=&quot;#7-typical-numbers-fp32&quot; aria-label=&quot;Anchor link for: 7-typical-numbers-fp32&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;x86 AVX-512: $L_{mul} \approx 3\text{–}4$, $L_{add} \approx 3\text{–}4$, $L_{fma} \approx 4$.&lt;br &#x2F;&gt;
Inequality holds if $P_{dup, path} &amp;lt; 2$ cycles.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;NVIDIA GPU (FP32 core): $L_{mul} \approx 4\text{–}6$, $L_{add} \approx 4\text{–}6$, $L_{fma} \approx 4\text{–}6$.&lt;br &#x2F;&gt;
Often equal; still beneficial when shortening dependency chains aids scheduling.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;ARM&#x2F;Apple: $L_{fma} \approx L_{mul}$ and both are small; inequality often holds for modest $P_{dup, path}$.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;8-implementation-sketch&quot;&gt;8. Implementation Sketch&lt;a class=&quot;zola-anchor&quot; href=&quot;#8-implementation-sketch&quot; aria-label=&quot;Anchor link for: 8-implementation-sketch&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;matching&quot;&gt;Matching&lt;a class=&quot;zola-anchor&quot; href=&quot;#matching&quot; aria-label=&quot;Anchor link for: matching&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;ol&gt;
&lt;li&gt;Match &lt;code&gt;mulf&lt;&#x2F;code&gt; feeding &lt;code&gt;addf&lt;&#x2F;code&gt; producing &lt;code&gt;%z&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;%y&lt;&#x2F;code&gt; has multiple uses.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;fastmath&lt;&#x2F;code&gt; includes &lt;code&gt;contract&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Target supports FMA (Fused Multiply-Add).&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;rewriting&quot;&gt;Rewriting&lt;a class=&quot;zola-anchor&quot; href=&quot;#rewriting&quot; aria-label=&quot;Anchor link for: rewriting&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp z-code&quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c++&quot;&gt;struct&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-struct z-c++&quot;&gt;SpeculativeFMA&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt; &lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-entity z-other z-inherited-class z-c++&quot;&gt;OpRewritePattern&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-generic z-begin z-c++&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;arith&lt;span class=&quot;z-punctuation z-accessor z-double-colon z-c++&quot;&gt;::&lt;&#x2F;span&gt;AddFOp&lt;span class=&quot;z-punctuation z-section z-generic z-end z-c++&quot;&gt;&amp;gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;  LogicalResult &lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;matchAndRewrite&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;arith&lt;span class=&quot;z-punctuation z-accessor z-double-colon z-c++&quot;&gt;::&lt;&#x2F;span&gt;AddFOp &lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;add&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;                                PatternRewriter &lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-parameter z-c++&quot;&gt;rewriter&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt; &lt;span class=&quot;z-storage z-modifier z-c++&quot;&gt;const&lt;&#x2F;span&gt; &lt;span class=&quot;z-storage z-modifier z-c++&quot;&gt;override&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-storage z-type z-c&quot;&gt;auto&lt;&#x2F;span&gt; mul &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; add&lt;span class=&quot;z-punctuation z-accessor z-dot z-c++&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;getLhs&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-c++&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;getDefiningOp&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-generic z-begin z-c++&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;arith&lt;span class=&quot;z-punctuation z-accessor z-double-colon z-c++&quot;&gt;::&lt;&#x2F;span&gt;MulFOp&lt;span class=&quot;z-punctuation z-section z-generic z-end z-c++&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;if&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;!&lt;&#x2F;span&gt;mul&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;failure&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;if&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;!&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;allowsContract&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;add&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;failure&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;if&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;mul&lt;span class=&quot;z-punctuation z-accessor z-dot z-c++&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;getResult&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-accessor z-dot z-c++&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;hasOneUse&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;failure&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt; &lt;span class=&quot;z-comment z-line z-double-slash z-c&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-comment z-c&quot;&gt;&#x2F;&#x2F;&lt;&#x2F;span&gt; handled elsewhere
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;if&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;!&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;targetHasFMA&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;add&lt;span class=&quot;z-punctuation z-accessor z-dot z-c++&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;getType&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;failure&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-storage z-type z-c&quot;&gt;double&lt;&#x2F;span&gt; Lmul &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-numeric z-float z-decimal z-c++&quot;&gt;4&lt;span class=&quot;z-punctuation z-separator z-decimal z-c++&quot;&gt;.&lt;&#x2F;span&gt;0&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; Ladd &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-numeric z-float z-decimal z-c++&quot;&gt;4&lt;span class=&quot;z-punctuation z-separator z-decimal z-c++&quot;&gt;.&lt;&#x2F;span&gt;0&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; Lfma &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-numeric z-float z-decimal z-c++&quot;&gt;4&lt;span class=&quot;z-punctuation z-separator z-decimal z-c++&quot;&gt;.&lt;&#x2F;span&gt;0&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; Pdup &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-constant z-numeric z-float z-decimal z-c++&quot;&gt;1&lt;span class=&quot;z-punctuation z-separator z-decimal z-c++&quot;&gt;.&lt;&#x2F;span&gt;0&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-keyword z-control z-c++&quot;&gt;if&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;Lmul &lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;+&lt;&#x2F;span&gt; Ladd &lt;span class=&quot;z-keyword z-operator z-comparison z-c&quot;&gt;&amp;lt;=&lt;&#x2F;span&gt; Lfma &lt;span class=&quot;z-keyword z-operator z-arithmetic z-c&quot;&gt;+&lt;&#x2F;span&gt; Pdup&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;failure&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-storage z-type z-c&quot;&gt;auto&lt;&#x2F;span&gt; fma &lt;span class=&quot;z-keyword z-operator z-assignment z-c&quot;&gt;=&lt;&#x2F;span&gt; rewriter&lt;span class=&quot;z-punctuation z-accessor z-dot z-c++&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;create&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-generic z-begin z-c++&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;arith&lt;span class=&quot;z-punctuation z-accessor z-double-colon z-c++&quot;&gt;::&lt;&#x2F;span&gt;FMAOp&lt;span class=&quot;z-punctuation z-section z-generic z-end z-c++&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;        add&lt;span class=&quot;z-punctuation z-accessor z-dot z-c++&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;getLoc&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; mul&lt;span class=&quot;z-punctuation z-accessor z-dot z-c++&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;getLhs&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; mul&lt;span class=&quot;z-punctuation z-accessor z-dot z-c++&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;getRhs&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; add&lt;span class=&quot;z-punctuation z-accessor z-dot z-c++&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;getRhs&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    rewriter&lt;span class=&quot;z-punctuation z-accessor z-dot z-c++&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;replaceOp&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;add&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; fma&lt;span class=&quot;z-punctuation z-accessor z-dot z-c++&quot;&gt;.&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-member z-c++&quot;&gt;getResult&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-keyword z-control z-flow z-return z-c++&quot;&gt;return&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;success&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;  &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;9-when-it-s-worth-it&quot;&gt;9. When It’s Worth It&lt;a class=&quot;zola-anchor&quot; href=&quot;#9-when-it-s-worth-it&quot; aria-label=&quot;Anchor link for: 9-when-it-s-worth-it&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Latency-bound regions:&lt;&#x2F;strong&gt; critical-path shortening dominates extra work.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Hardware FMA available:&lt;&#x2F;strong&gt; FMA throughput ≈ MUL throughput.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Moderate register pressure:&lt;&#x2F;strong&gt; duplication penalty small.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Fast-math with contraction:&lt;&#x2F;strong&gt; legally allowed transformation.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;when-it-isn-t&quot;&gt;When It Isn’t&lt;a class=&quot;zola-anchor&quot; href=&quot;#when-it-isn-t&quot; aria-label=&quot;Anchor link for: when-it-isn-t&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;Throughput-bound code with wide ILP (Instruction Level Parallelism).&lt;&#x2F;li&gt;
&lt;li&gt;High register pressure or spilling (large $P_{dup, path}$).&lt;&#x2F;li&gt;
&lt;li&gt;Targets that lower FMA (Fused Multiply-Add) back into &lt;code&gt;mul+add&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Strict IEEE (Institute of Electrical and Electronics Engineers)-754 without &lt;code&gt;contract&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;10-summary&quot;&gt;10. Summary&lt;a class=&quot;zola-anchor&quot; href=&quot;#10-summary&quot; aria-label=&quot;Anchor link for: 10-summary&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Goal:&lt;&#x2F;strong&gt; Improve latency on a hot path by fusing multiply and add via duplication.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Mechanism:&lt;&#x2F;strong&gt; Duplicate the multiply so one consumer can form an &lt;code&gt;fma&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Decision rule:&lt;&#x2F;strong&gt; apply if
$$
L_{mul} + L_{add} &amp;gt; L_{fma} + P_{dup, path}.
$$&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Key idea:&lt;&#x2F;strong&gt; judge by &lt;strong&gt;critical-path latency&lt;&#x2F;strong&gt;, not &lt;strong&gt;total instruction count&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Legality:&lt;&#x2F;strong&gt; requires &lt;code&gt;fastmath=contract&lt;&#x2F;code&gt; and hardware FMA.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;11-takeaway&quot;&gt;11. Takeaway&lt;a class=&quot;zola-anchor&quot; href=&quot;#11-takeaway&quot; aria-label=&quot;Anchor link for: 11-takeaway&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;Speculative duplication in MLIR (Multi-Level Intermediate Representation) is not about doing &lt;em&gt;less&lt;&#x2F;em&gt; work—it is about &lt;strong&gt;restructuring dependency graphs&lt;&#x2F;strong&gt; to shorten &lt;em&gt;critical latency paths&lt;&#x2F;em&gt;. The compiler duplicates an operation only when a &lt;strong&gt;path-aware cost model&lt;&#x2F;strong&gt; predicts that the shorter dependency chain outweighs any overhead from added instructions, register pressure, or scheduling noise.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>MLIR as a Rewritable Graph Database</title>
		<published>2025-10-04T00:00:00+00:00</published>
		<updated>2025-10-04T00:00:00+00:00</updated>
		<link rel="alternate" type="text/html" href="https://josephbak.github.io/notes/mlir-graph-db-analogy/"/>
		<id>https://josephbak.github.io/notes/mlir-graph-db-analogy/</id>
    
		<content type="html" xml:base="https://josephbak.github.io/notes/mlir-graph-db-analogy/">&lt;h2 id=&quot;1-concept-overview&quot;&gt;1. Concept Overview&lt;a class=&quot;zola-anchor&quot; href=&quot;#1-concept-overview&quot; aria-label=&quot;Anchor link for: 1-concept-overview&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;MLIR (Multi-Level Intermediate Representation)&lt;&#x2F;strong&gt; can be understood not just as a compiler IR framework, but as a &lt;em&gt;rewritable, typed graph database&lt;&#x2F;em&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;At its core, MLIR stores structured, typed, and interconnected data (operations and values) that can be &lt;strong&gt;queried, transformed, and restructured&lt;&#x2F;strong&gt; — just like a database manages records with schema and queries.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Database Concept&lt;&#x2F;th&gt;&lt;th&gt;MLIR Equivalent&lt;&#x2F;th&gt;&lt;th&gt;Description&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Schema&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Operation definitions (via TableGen)&lt;&#x2F;td&gt;&lt;td&gt;Define what nodes (ops) can exist and what fields (operands, attributes) they have.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Records&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Operation instances in IR&lt;&#x2F;td&gt;&lt;td&gt;Concrete nodes representing program fragments.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Query &#x2F; Update&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Rewrite patterns (DRR or C++)&lt;&#x2F;td&gt;&lt;td&gt;Declarative or imperative transformations on subsets of the IR graph.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Query Engine&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Pass manager &#x2F; pattern driver&lt;&#x2F;td&gt;&lt;td&gt;Executes rewrites efficiently, ensuring consistency and termination.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Materialized View&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;.mlir&lt;&#x2F;code&gt; textual snapshot&lt;&#x2F;td&gt;&lt;td&gt;Human-readable dump of current IR database state.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;So MLIR ≈ &lt;em&gt;a database of program operations&lt;&#x2F;em&gt;, where &lt;strong&gt;dialects&lt;&#x2F;strong&gt; define schemas, &lt;strong&gt;rewrites&lt;&#x2F;strong&gt; define queries&#x2F;updates, and &lt;strong&gt;passes&lt;&#x2F;strong&gt; execute those transformations.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;2-why-database-not-just-graph&quot;&gt;2. Why &quot;Database&quot;, Not Just &quot;Graph&quot;&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-why-database-not-just-graph&quot; aria-label=&quot;Anchor link for: 2-why-database-not-just-graph&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;MLIR’s IR is a &lt;strong&gt;typed, modular, and queryable graph&lt;&#x2F;strong&gt;, not a raw untyped DAG (Directed Acyclic Graph). Here’s the key distinction:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Aspect&lt;&#x2F;th&gt;&lt;th&gt;Plain Graph&lt;&#x2F;th&gt;&lt;th&gt;MLIR as Graph Database&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Structure&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Unstructured nodes&#x2F;edges&lt;&#x2F;td&gt;&lt;td&gt;Nodes (ops) and edges (values) with rich typing.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Schema&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;None&lt;&#x2F;td&gt;&lt;td&gt;Defined in ODS&#x2F;TableGen dialects.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Queries&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Manual graph traversal&lt;&#x2F;td&gt;&lt;td&gt;Pattern-matching and rewrite rules.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Transactions&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Not defined&lt;&#x2F;td&gt;&lt;td&gt;PatternRewriter guarantees consistent state after rewrite.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Namespaces&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Flat&lt;&#x2F;td&gt;&lt;td&gt;Modular dialects (isolated schemas).&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Persistence&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Optional&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;.mlir&lt;&#x2F;code&gt; provides textual serialization.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Thus, the term &lt;em&gt;database&lt;&#x2F;em&gt; highlights the presence of:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Schema-driven structure&lt;&#x2F;strong&gt; (dialects + ops)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Rule-driven updates&lt;&#x2F;strong&gt; (rewrites)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Transaction-like consistency&lt;&#x2F;strong&gt; (rewrites maintain SSA, type, dominance)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Query semantics&lt;&#x2F;strong&gt; (find + replace via patterns)&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;3-the-core-mapping&quot;&gt;3. The Core Mapping&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-the-core-mapping&quot; aria-label=&quot;Anchor link for: 3-the-core-mapping&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;ops-schema&quot;&gt;Ops = Schema&lt;a class=&quot;zola-anchor&quot; href=&quot;#ops-schema&quot; aria-label=&quot;Anchor link for: ops-schema&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;Define what data (ops) can exist in the IR:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;tablegen&quot; class=&quot;language-tablegen z-code&quot;&gt;&lt;code class=&quot;language-tablegen&quot; data-lang=&quot;tablegen&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;def TFL_LeakyReluOp : TFL_Op&amp;lt;TFL_Dialect, &amp;quot;leaky_relu&amp;quot;, [NoMemoryEffect, SameValueType]&amp;gt; {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  let arguments = (ins F32Tensor:$x, F32Attr:$alpha);
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  let results   = (outs F32Tensor:$y);
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;This is analogous to:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sql&quot; class=&quot;language-sql z-code&quot;&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span class=&quot;z-source z-sql&quot;&gt;&lt;span class=&quot;z-meta z-create z-sql&quot;&gt;&lt;span class=&quot;z-keyword z-other z-create z-sql&quot;&gt;CREATE&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-other z-sql&quot;&gt;TABLE&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-toc-list z-full-identifier z-sql&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-sql&quot;&gt;LeakyRelu&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; (x FLOAT, alpha FLOAT, y FLOAT);
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Each operation instance is a &lt;em&gt;record&lt;&#x2F;em&gt; conforming to this schema.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;patterns-rewrite-rules&quot;&gt;Patterns = Rewrite Rules&lt;a class=&quot;zola-anchor&quot; href=&quot;#patterns-rewrite-rules&quot; aria-label=&quot;Anchor link for: patterns-rewrite-rules&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;Declarative DRR or imperative C++ patterns are like database &lt;em&gt;update queries&lt;&#x2F;em&gt;:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;tablegen&quot; class=&quot;language-tablegen z-code&quot;&gt;&lt;code class=&quot;language-tablegen&quot; data-lang=&quot;tablegen&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;def : Pat&amp;lt;(TF_LeakyReluOp $x, F32Attr:$a), (TFL_LeakyReluOp $x, $a)&amp;gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Equivalent to:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sql&quot; class=&quot;language-sql z-code&quot;&gt;&lt;code class=&quot;language-sql&quot; data-lang=&quot;sql&quot;&gt;&lt;span class=&quot;z-source z-sql&quot;&gt;&lt;span class=&quot;z-keyword z-other z-DML z-sql&quot;&gt;UPDATE&lt;&#x2F;span&gt; ops &lt;span class=&quot;z-keyword z-other z-DML z-sql&quot;&gt;SET&lt;&#x2F;span&gt; dialect &lt;span class=&quot;z-keyword z-operator z-comparison z-sql&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-string z-quoted z-single z-sql&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-string z-begin z-sql&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;tfl&lt;span class=&quot;z-punctuation z-definition z-string z-end z-sql&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-keyword z-other z-DML z-sql&quot;&gt;WHERE&lt;&#x2F;span&gt; op &lt;span class=&quot;z-keyword z-operator z-comparison z-sql&quot;&gt;=&lt;&#x2F;span&gt; &lt;span class=&quot;z-string z-quoted z-single z-sql&quot;&gt;&lt;span class=&quot;z-punctuation z-definition z-string z-begin z-sql&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;tf.LeakyRelu&lt;span class=&quot;z-punctuation z-definition z-string z-end z-sql&quot;&gt;&amp;#39;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;They match subgraphs and replace them with new equivalent forms.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;passes-query-engine&quot;&gt;Passes = Query Engine&lt;a class=&quot;zola-anchor&quot; href=&quot;#passes-query-engine&quot; aria-label=&quot;Anchor link for: passes-query-engine&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;p&gt;Passes orchestrate which rewrites run and in what order:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Apply rewrites until fixpoint (no matches).&lt;&#x2F;li&gt;
&lt;li&gt;Maintain consistency (SSA, type legality).&lt;&#x2F;li&gt;
&lt;li&gt;Optimize or lower IR progressively.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Example:&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;cpp&quot; class=&quot;language-cpp z-code&quot;&gt;&lt;code class=&quot;language-cpp&quot; data-lang=&quot;cpp&quot;&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-storage z-type z-c++&quot;&gt;struct&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-struct z-c++&quot;&gt;LegalizeTFToTFLPass&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt; &lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;:&lt;&#x2F;span&gt; &lt;span class=&quot;z-storage z-modifier z-c++&quot;&gt;public&lt;&#x2F;span&gt; &lt;span class=&quot;z-entity z-other z-inherited-class z-c++&quot;&gt;PassWrapper&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-generic z-begin z-c++&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;LegalizeTFToTFLPass&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; OperationPass&lt;span class=&quot;z-punctuation z-section z-generic z-begin z-c++&quot;&gt;&amp;lt;&lt;&#x2F;span&gt;ModuleOp&lt;span class=&quot;z-punctuation z-section z-generic z-end z-c++&quot;&gt;&amp;gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-generic z-end z-c++&quot;&gt;&amp;gt;&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;  &lt;span class=&quot;z-storage z-type z-c&quot;&gt;void&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-entity z-name z-function z-c++&quot;&gt;runOnOperation&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-parameters z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt; &lt;span class=&quot;z-storage z-modifier z-c++&quot;&gt;override&lt;&#x2F;span&gt; &lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-begin z-c++&quot;&gt;{&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    RewritePatternSet &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;patterns&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-keyword z-operator z-c&quot;&gt;&amp;amp;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;getContext&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;populateWithGenerated&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;patterns&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;    &lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;span class=&quot;z-storage z-type z-c&quot;&gt;void&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;applyPatternsAndFoldGreedily&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;getOperation&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-separator z-c++&quot;&gt;,&lt;&#x2F;span&gt; &lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;std&lt;span class=&quot;z-punctuation z-accessor z-double-colon z-c++&quot;&gt;::&lt;&#x2F;span&gt;&lt;span class=&quot;z-variable z-function z-c++&quot;&gt;move&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-begin z-c++&quot;&gt;(&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;patterns&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-function-call z-c++&quot;&gt;&lt;span class=&quot;z-meta z-group z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-group z-end z-c++&quot;&gt;)&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;  &lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-method z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-source z-c++&quot;&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-meta z-struct z-c++&quot;&gt;&lt;span class=&quot;z-meta z-block z-c++&quot;&gt;&lt;span class=&quot;z-punctuation z-section z-block z-end z-c++&quot;&gt;}&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;&#x2F;span&gt;&lt;span class=&quot;z-punctuation z-terminator z-c++&quot;&gt;;&lt;&#x2F;span&gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;4-related-work-and-analogues&quot;&gt;4. Related Work and Analogues&lt;a class=&quot;zola-anchor&quot; href=&quot;#4-related-work-and-analogues&quot; aria-label=&quot;Anchor link for: 4-related-work-and-analogues&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;a-compilers-as-databases&quot;&gt;a. Compilers as Databases&lt;a class=&quot;zola-anchor&quot; href=&quot;#a-compilers-as-databases&quot; aria-label=&quot;Anchor link for: a-compilers-as-databases&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Martin Odersky (Scala creator)&lt;&#x2F;strong&gt;: described compilers as &lt;em&gt;in-memory databases&lt;&#x2F;em&gt; that store program facts and derive new ones.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Reddit&#x2F;HackerNews discussions&lt;&#x2F;strong&gt;: reinforce the view of compilers as structured data systems that can be queried and transformed.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;b-mlir-research&quot;&gt;b. MLIR Research&lt;a class=&quot;zola-anchor&quot; href=&quot;#b-mlir-research&quot; aria-label=&quot;Anchor link for: b-mlir-research&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;MLIR LangRef:&lt;&#x2F;strong&gt; describes the IR as a &lt;em&gt;graph of operations and values&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;MLIR for Graph Algorithms (LLVM Doc):&lt;&#x2F;strong&gt; formalizes MLIR as a graph manipulation substrate.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Relational MLIR Dialects:&lt;&#x2F;strong&gt; academic work modeling &lt;em&gt;relational algebra&lt;&#x2F;em&gt; as MLIR dialects for query optimization (e.g., PVLDB 2022, Jungmair et al.).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Equality Saturation (Egg&#x2F;MLIR integration):&lt;&#x2F;strong&gt; uses e-graphs (equivalence graphs) as rewrite databases for exploring all possible transformations simultaneously.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;c-database-style-compilers&quot;&gt;c. Database-style Compilers&lt;a class=&quot;zola-anchor&quot; href=&quot;#c-database-style-compilers&quot; aria-label=&quot;Anchor link for: c-database-style-compilers&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Soufflé Datalog Compiler:&lt;&#x2F;strong&gt; represents program facts as relations; transformations and analyses as queries.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Flix, QL, CodeQL:&lt;&#x2F;strong&gt; treat program analysis as querying a database of IR facts.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Egglog &#x2F; E-graphs:&lt;&#x2F;strong&gt; treat rewrites as fact insertions and equivalence updates.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;5-where-the-analogy-fails&quot;&gt;5. Where the Analogy Fails&lt;a class=&quot;zola-anchor&quot; href=&quot;#5-where-the-analogy-fails&quot; aria-label=&quot;Anchor link for: 5-where-the-analogy-fails&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;While the &lt;em&gt;conceptual mapping&lt;&#x2F;em&gt; is strong, MLIR isn’t a literal database.&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Database Property&lt;&#x2F;th&gt;&lt;th&gt;MLIR Reality&lt;&#x2F;th&gt;&lt;th&gt;Why it breaks&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Persistence &amp;amp; durability (ACID)&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;In-memory IR, no transaction logs&lt;&#x2F;td&gt;&lt;td&gt;MLIR rewrites are ephemeral and non-rollbackable.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Relational query language&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;No general SQL&#x2F;Datalog layer&lt;&#x2F;td&gt;&lt;td&gt;Rewrites are specialized, not general-purpose.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Concurrency &amp;amp; isolation&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Single-threaded mutation&lt;&#x2F;td&gt;&lt;td&gt;No multi-user or concurrent transactions.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;Indexing and query optimization&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Manual traversal&lt;&#x2F;td&gt;&lt;td&gt;Pattern matching is structural, not cost-based.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;strong&gt;General data model&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;td&gt;Program IR only&lt;&#x2F;td&gt;&lt;td&gt;Can’t represent arbitrary user data.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;So the analogy fails when expecting full DBMS features. MLIR is &lt;em&gt;database-like&lt;&#x2F;em&gt; in structure and semantics, not in engineering.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;6-why-the-analogy-still-matters&quot;&gt;6. Why the Analogy Still Matters&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-why-the-analogy-still-matters&quot; aria-label=&quot;Anchor link for: 6-why-the-analogy-still-matters&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;Despite its limits, the framing of MLIR as a &lt;em&gt;graph database of program operations&lt;&#x2F;em&gt; is:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pedagogically powerful:&lt;&#x2F;strong&gt; clarifies dialects as schemas, rewrites as queries, and passes as engines.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Architecturally descriptive:&lt;&#x2F;strong&gt; explains why MLIR scales — modular schemas, composable transformations, structured consistency.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Future-oriented:&lt;&#x2F;strong&gt; MLIR could evolve toward persistent or incremental IR stores, especially for IDEs or incremental compilers.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;In short:&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;MLIR bridges compiler theory and data systems. Thinking of it as a &lt;em&gt;rewritable graph database&lt;&#x2F;em&gt; highlights how its modular, queryable, schema-driven architecture goes beyond a traditional IR graph.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;7-key-references&quot;&gt;7. Key References&lt;a class=&quot;zola-anchor&quot; href=&quot;#7-key-references&quot; aria-label=&quot;Anchor link for: 7-key-references&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mlir.llvm.org&#x2F;docs&#x2F;LangRef&#x2F;&quot;&gt;MLIR LangRef – Structure of IR&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;mlir.llvm.org&#x2F;docs&#x2F;Rationale&#x2F;MLIRForGraphAlgorithms&#x2F;&quot;&gt;MLIR for Graph Algorithms (LLVM Rationale Doc)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;www.vldb.org&#x2F;pvldb&#x2F;vol15&#x2F;p2389-jungmair.pdf&quot;&gt;PVLDB 2022 – &quot;An MLIR Dialect for Relational Algebra&quot;&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;egraphs-good.github.io&#x2F;&quot;&gt;Egg and Equality Saturation&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;souffle-lang.github.io&#x2F;&quot;&gt;Soufflé Datalog Compiler&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a rel=&quot;nofollow noreferrer&quot; href=&quot;https:&#x2F;&#x2F;news.ycombinator.com&#x2F;item?id=10037971&quot;&gt;Martin Odersky – Compilers as Databases (Talk summary)&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;strong&gt;TL;DR:&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;MLIR is not just a graph of operations — it’s a typed, schema-driven, queryable &lt;em&gt;graph database&lt;&#x2F;em&gt; for program transformations. Dialects define the schema, rewrites define the queries, and passes execute them to evolve the IR toward hardware or optimized form.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Evolution of Branch Prediction and Its Parallels with SSA → SSI</title>
		<published>2025-10-03T00:00:00+00:00</published>
		<updated>2025-10-03T00:00:00+00:00</updated>
		<link rel="alternate" type="text/html" href="https://josephbak.github.io/notes/branch-prediction-ssa-note/"/>
		<id>https://josephbak.github.io/notes/branch-prediction-ssa-note/</id>
    
		<content type="html" xml:base="https://josephbak.github.io/notes/branch-prediction-ssa-note/">&lt;h1 id=&quot;evolution-of-branch-prediction-and-its-parallels-with-ssa-ssi&quot;&gt;Evolution of Branch Prediction and Its Parallels with SSA → SSI&lt;a class=&quot;zola-anchor&quot; href=&quot;#evolution-of-branch-prediction-and-its-parallels-with-ssa-ssi&quot; aria-label=&quot;Anchor link for: evolution-of-branch-prediction-and-its-parallels-with-ssa-ssi&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h1&gt;
&lt;h2 id=&quot;1-branch-prediction-evolution&quot;&gt;1. Branch Prediction Evolution&lt;a class=&quot;zola-anchor&quot; href=&quot;#1-branch-prediction-evolution&quot; aria-label=&quot;Anchor link for: 1-branch-prediction-evolution&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;Branch prediction has been one of the most important microarchitectural
techniques for exploiting instruction-level parallelism in CPUs.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Static Prediction (pre-1980s):&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;Early CPUs simply recorded which way the branch went last time
and predicted the same outcome.&lt;&#x2F;li&gt;
&lt;li&gt;Accuracy: ~85%.&lt;&#x2F;li&gt;
&lt;li&gt;Hardware cost: ~1K bits.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Two-bit and Multi-bit Counters (1980s--1990s):&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;Added history with saturating counters (2-bit, 3-bit, etc.).&lt;&#x2F;li&gt;
&lt;li&gt;Improved accuracy to ~90--92%.&lt;&#x2F;li&gt;
&lt;li&gt;Example: &quot;predict taken if counter ≥ threshold.&quot;&lt;&#x2F;li&gt;
&lt;li&gt;Hardware: a few kilobits.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Global + Local History (1990s--2000s):&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;Recognized that outcome may depend on &lt;em&gt;how you got there&lt;&#x2F;em&gt; (path
history).&lt;&#x2F;li&gt;
&lt;li&gt;E.g., &quot;Bob likes Jane&quot; vs &quot;Bob likes Jill&quot; example → different
outcomes.&lt;&#x2F;li&gt;
&lt;li&gt;Combined global history with counters.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Neural &#x2F; Perceptron Predictors (2000s--today):&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;Use perceptron-like learning: weight vectors times history bits.&lt;&#x2F;li&gt;
&lt;li&gt;Essentially a small neural net in silicon.&lt;&#x2F;li&gt;
&lt;li&gt;Accuracy &amp;gt;95--99%.&lt;&#x2F;li&gt;
&lt;li&gt;Hardware cost: tens of megabits.&lt;&#x2F;li&gt;
&lt;li&gt;Modern branch predictors are like &quot;tiny supercomputers&quot; inside
CPUs.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Speculative Execution with Invariance Tracking (modern
research):&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;Even if mispredicted, CPU can sometimes reuse invariant
computations.&lt;&#x2F;li&gt;
&lt;li&gt;Analogy: misunderstanding a paragraph but still being able to
use facts in the next one.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;2-ssa-ssi-evolution&quot;&gt;2. SSA → SSI Evolution&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-ssa-ssi-evolution&quot; aria-label=&quot;Anchor link for: 2-ssa-ssi-evolution&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;In compiler theory, Static Single Assignment (SSA) form also evolved to
handle path-sensitive information, which parallels branch prediction
evolution.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SSA (1980s):&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;Each variable is assigned exactly once.&lt;&#x2F;li&gt;
&lt;li&gt;φ-nodes merge values from different control-flow paths.&lt;&#x2F;li&gt;
&lt;li&gt;Enables easier dataflow analysis.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;SSI (Static Single Information, 1990s):&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;Extends SSA with σ-nodes (propagation of &lt;em&gt;predicates&lt;&#x2F;em&gt; along
branches).&lt;&#x2F;li&gt;
&lt;li&gt;Adds history&#x2F;context: the value of a variable may depend on the
&lt;em&gt;branch condition&lt;&#x2F;em&gt; taken.&lt;&#x2F;li&gt;
&lt;li&gt;This is similar to branch predictors adding &lt;em&gt;path history&lt;&#x2F;em&gt; for
accuracy.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;3-parallels-between-branch-prediction-and-ssa-ssi&quot;&gt;3. Parallels Between Branch Prediction and SSA → SSI&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-parallels-between-branch-prediction-and-ssa-ssi&quot; aria-label=&quot;Anchor link for: 3-parallels-between-branch-prediction-and-ssa-ssi&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Base Case (Last Outcome vs SSA):&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;Last-outcome prediction is like plain SSA: keeps track of values
(or outcomes) but without context.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Adding History (Counters vs σ-nodes):&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;Multi-bit counters and global history parallel the move from SSA
to SSI, where additional information (context) is preserved.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Learning-based (Neural Predictors vs Path-sensitive IR):&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;Just as neural predictors recognize deeper patterns, SSI and
advanced compiler IRs capture richer flow-sensitive invariants.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;4-timeline-summary&quot;&gt;4. Timeline Summary&lt;a class=&quot;zola-anchor&quot; href=&quot;#4-timeline-summary&quot; aria-label=&quot;Anchor link for: 4-timeline-summary&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;1980s:&lt;&#x2F;strong&gt; Last-outcome prediction, SSA formalization.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;1990s:&lt;&#x2F;strong&gt; Two-bit counters, global history predictors, SSI
introduction.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;2000s--2020s:&lt;&#x2F;strong&gt; Perceptron predictors, neural nets; research into
predicate-sensitive IR and advanced SSA variants.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;5-references-papers&quot;&gt;5. References &#x2F; Papers&lt;a class=&quot;zola-anchor&quot; href=&quot;#5-references-papers&quot; aria-label=&quot;Anchor link for: 5-references-papers&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;J.E. Smith, &quot;A study of branch prediction strategies,&quot; ISCA 1981.\&lt;&#x2F;li&gt;
&lt;li&gt;Yeh &amp;amp; Patt, &quot;Two-level adaptive branch prediction,&quot; MICRO 1991.\&lt;&#x2F;li&gt;
&lt;li&gt;Jiménez &amp;amp; Lin, &quot;Dynamic Branch Prediction with Perceptrons,&quot; HPCA
2001.\&lt;&#x2F;li&gt;
&lt;li&gt;Cytron et al., &quot;Efficiently Computing Static Single Assignment
Form,&quot; TOPLAS 1991.\&lt;&#x2F;li&gt;
&lt;li&gt;Ananian, &quot;The Static Single Information Form,&quot; MIT CSAIL TR-827,
1999.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>MLIR Generic DAG Rewriter</title>
		<published>2025-10-02T00:00:00+00:00</published>
		<updated>2025-10-02T00:00:00+00:00</updated>
		<link rel="alternate" type="text/html" href="https://josephbak.github.io/notes/mlir-generic-dag-rewriter/"/>
		<id>https://josephbak.github.io/notes/mlir-generic-dag-rewriter/</id>
    
		<content type="html" xml:base="https://josephbak.github.io/notes/mlir-generic-dag-rewriter/">&lt;!-- Notes on MLIR (Multi-Level Intermediate Representation) Generic DAG (Directed Acyclic Graph) Rewriter --&gt;
&lt;p&gt;A compact, publish‑ready summary of what I learned from &lt;strong&gt;https:&#x2F;&#x2F;mlir.llvm.org&#x2F;docs&#x2F;Rationale&#x2F;RationaleGenericDAGRewriter&#x2F;&lt;&#x2F;strong&gt; and the discussion.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;tl-dr&quot;&gt;TL;DR&lt;a class=&quot;zola-anchor&quot; href=&quot;#tl-dr&quot; aria-label=&quot;Anchor link for: tl-dr&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;MLIR (Multi-Level Intermediate Representation) needs a &lt;strong&gt;general DAG (Directed Acyclic Graph)-to-DAG (Directed Acyclic Graph)&lt;&#x2F;strong&gt; rewrite engine to handle many optimizations and lowerings across abstraction levels.&lt;&#x2F;li&gt;
&lt;li&gt;This is different from &lt;strong&gt;CSE (Common Subexpression Elimination)&lt;&#x2F;strong&gt;: DAG (Directed Acyclic Graph) rewriting &lt;strong&gt;changes&lt;&#x2F;strong&gt; the shape (e.g., fuse &lt;code&gt;mul+add&lt;&#x2F;code&gt; → &lt;strong&gt;FMA (Fused Multiply Add)&lt;&#x2F;strong&gt;); CSE (Common Subexpression Elimination) only &lt;strong&gt;deduplicates&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;The infrastructure aims for &lt;strong&gt;declarative, reusable patterns&lt;&#x2F;strong&gt;, robust legality checks, good diagnostics, and flexible algorithms because global DAG tiling is &lt;strong&gt;NP (Nondeterministic Polynomial time)-complete&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;core-idea-match-one-dag-directed-acyclic-graph-replace-with-another&quot;&gt;Core idea: “Match one DAG (Directed Acyclic Graph), replace with another”&lt;a class=&quot;zola-anchor&quot; href=&quot;#core-idea-match-one-dag-directed-acyclic-graph-replace-with-another&quot; aria-label=&quot;Anchor link for: core-idea-match-one-dag-directed-acyclic-graph-replace-with-another&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;IR (Intermediate Representation) is a graph: nodes = &lt;strong&gt;operations&lt;&#x2F;strong&gt;, edges = &lt;strong&gt;SSA (Static Single Assignment) values&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;Pattern rewriter finds a &lt;strong&gt;subgraph&lt;&#x2F;strong&gt; (e.g., &lt;code&gt;add&lt;&#x2F;code&gt; feeding &lt;code&gt;mul&lt;&#x2F;code&gt;) and replaces it with an &lt;strong&gt;equivalent&lt;&#x2F;strong&gt; but better subgraph (e.g., a single &lt;strong&gt;FMA (Fused Multiply Add)&lt;&#x2F;strong&gt;).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;ASCII&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;Before:            After:
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; a   b   c          a   b   c
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  \ &#x2F;               \ | &#x2F;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  add                fma         # (a + b) * c
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   |                               
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;   v
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  mul
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;canonicalization-vs-constant-folding-vs-clients&quot;&gt;Canonicalization vs Constant Folding vs Clients&lt;a class=&quot;zola-anchor&quot; href=&quot;#canonicalization-vs-constant-folding-vs-clients&quot; aria-label=&quot;Anchor link for: canonicalization-vs-constant-folding-vs-clients&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Canonicalization&lt;&#x2F;strong&gt;: normalize equivalent forms (e.g., &lt;code&gt;x+0 → x&lt;&#x2F;code&gt;, reorder commutative ops) so later passes see a &lt;strong&gt;standard&lt;&#x2F;strong&gt; shape.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Constant folding&lt;&#x2F;strong&gt;: if operands are constants, compute the result constant. In MLIR (Multi-Level Intermediate Representation), &lt;code&gt;fold()&lt;&#x2F;code&gt; &lt;strong&gt;returns&lt;&#x2F;strong&gt; constants; &lt;strong&gt;clients&lt;&#x2F;strong&gt; (passes like canonicalizer) update IR (Intermediate Representation). This avoids iterator invalidation.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Clients&lt;&#x2F;strong&gt; = the users of these APIs (Application Programming Interfaces): canonicalization, simplifiers, etc.—they call &lt;code&gt;op.fold()&lt;&#x2F;code&gt; and perform the IR (Intermediate Representation) edits safely.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;ast-abstract-syntax-tree-vs-dag-directed-acyclic-graph&quot;&gt;AST (Abstract Syntax Tree) vs DAG (Directed Acyclic Graph)&lt;a class=&quot;zola-anchor&quot; href=&quot;#ast-abstract-syntax-tree-vs-dag-directed-acyclic-graph&quot; aria-label=&quot;Anchor link for: ast-abstract-syntax-tree-vs-dag-directed-acyclic-graph&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;AST (Abstract Syntax Tree)&lt;&#x2F;strong&gt; is a &lt;strong&gt;tree&lt;&#x2F;strong&gt; → no natural sharing; &lt;code&gt;(x+y)&lt;&#x2F;code&gt; duplicated in &lt;code&gt;(x+y)*(x+y)&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;DAG (Directed Acyclic Graph)&lt;&#x2F;strong&gt; permits sharing; one node for &lt;code&gt;(x+y)&lt;&#x2F;code&gt; with two uses.&lt;&#x2F;li&gt;
&lt;li&gt;DAG (Directed Acyclic Graph) matching is more powerful than tree matching, but must guard against &lt;strong&gt;duplicating&lt;&#x2F;strong&gt; shared work.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;how-dag-directed-acyclic-graph-sharing-happens-construction&quot;&gt;How DAG (Directed Acyclic Graph) sharing happens (construction)&lt;a class=&quot;zola-anchor&quot; href=&quot;#how-dag-directed-acyclic-graph-sharing-happens-construction&quot; aria-label=&quot;Anchor link for: how-dag-directed-acyclic-graph-sharing-happens-construction&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Hash‑consing &#x2F; value numbering&lt;&#x2F;strong&gt;: map &lt;code&gt;(op, operands, attributes, types)&lt;&#x2F;code&gt; → existing node; reuse it instead of re‑creating.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;SSA (Static Single Assignment)&lt;&#x2F;strong&gt; naturally encodes sharing: one definition, many uses.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;cse-common-subexpression-elimination-vs-peephole-combiners&quot;&gt;CSE (Common Subexpression Elimination) vs Peephole “Combiners”&lt;a class=&quot;zola-anchor&quot; href=&quot;#cse-common-subexpression-elimination-vs-peephole-combiners&quot; aria-label=&quot;Anchor link for: cse-common-subexpression-elimination-vs-peephole-combiners&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CSE (Common Subexpression Elimination)&lt;&#x2F;strong&gt;: remove &lt;strong&gt;duplicate&lt;&#x2F;strong&gt; equivalent ops when the earlier one &lt;strong&gt;dominates&lt;&#x2F;strong&gt; the later.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Combiners&lt;&#x2F;strong&gt; (peepholes): local &lt;strong&gt;algebraic rewrites&lt;&#x2F;strong&gt; within a small window (e.g., fuse, fold, strength‑reduce). Order and local cost matter.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Strength reduction examples&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x*2 → x&amp;lt;&amp;lt;1&lt;&#x2F;code&gt; (bit‑shift), &lt;code&gt;x%2^k → x&amp;amp;(2^k−1)&lt;&#x2F;code&gt; for &lt;strong&gt;unsigned&lt;&#x2F;strong&gt; or non‑negative &lt;code&gt;x&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;For non‑power‑of‑two divisors, use “magic” multiply+shift sequences, not masking.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;dominance-hoisting-licm-loop-invariant-code-motion-gvn-global-value-numbering-cfg-control-flow-graph&quot;&gt;Dominance, Hoisting, LICM (Loop‑Invariant Code Motion), GVN (Global Value Numbering), CFG (Control‑Flow Graph)&lt;a class=&quot;zola-anchor&quot; href=&quot;#dominance-hoisting-licm-loop-invariant-code-motion-gvn-global-value-numbering-cfg-control-flow-graph&quot; aria-label=&quot;Anchor link for: dominance-hoisting-licm-loop-invariant-code-motion-gvn-global-value-numbering-cfg-control-flow-graph&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Dominance&lt;&#x2F;strong&gt;: A dominates B if A is executed &lt;strong&gt;on every path&lt;&#x2F;strong&gt; to B.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Hoisting&lt;&#x2F;strong&gt;: move an op to a &lt;strong&gt;dominating&lt;&#x2F;strong&gt; block so it runs once and is reused. Trade‑off: longer live ranges → higher &lt;strong&gt;register pressure&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;LICM (Loop‑Invariant Code Motion)&lt;&#x2F;strong&gt;: move loop‑invariant work to the loop preheader (or sink it) when safe&#x2F;profitable.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;GVN (Global Value Numbering)&lt;&#x2F;strong&gt;: global equivalence + redundancy elimination across the &lt;strong&gt;CFG (Control‑Flow Graph)&lt;&#x2F;strong&gt; (MLIR (Multi-Level Intermediate Representation) core relies more on CSE (Common Subexpression Elimination), canonicalization, SCCP (Sparse Conditional Constant Propagation), etc.; classic GVN (Global Value Numbering) is on the LLVM (Low Level Virtual Machine) side).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;CFG (Control‑Flow Graph)&lt;&#x2F;strong&gt;: nodes = basic blocks; edges = possible control transfer.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;mlir-multi-level-intermediate-representation-rewrite-infrastructure&quot;&gt;MLIR (Multi-Level Intermediate Representation) rewrite infrastructure&lt;a class=&quot;zola-anchor&quot; href=&quot;#mlir-multi-level-intermediate-representation-rewrite-infrastructure&quot; aria-label=&quot;Anchor link for: mlir-multi-level-intermediate-representation-rewrite-infrastructure&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;RewritePattern + PatternRewriter&lt;&#x2F;strong&gt; with greedy drivers (&lt;code&gt;applyPatternsAndFoldGreedily&lt;&#x2F;code&gt;).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;DRR (Declarative Rewrite Rules)&lt;&#x2F;strong&gt; (TableGen) and &lt;strong&gt;PDL&#x2F;PDLL (Pattern Description Language &#x2F; Pattern Description Language frontend)&lt;&#x2F;strong&gt; for declarative pattern authoring.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Canonicalizer&lt;&#x2F;strong&gt; + op‑level &lt;code&gt;fold()&lt;&#x2F;code&gt; unify local cleanups.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Dialect Conversion&lt;&#x2F;strong&gt;: legality, 1→N&#x2F;N→M rewrites, type conversion; not just peepholes.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Transform dialect&lt;&#x2F;strong&gt;: orchestrate how&#x2F;where to apply transformations using IR (Intermediate Representation) itself.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;llvm-low-level-virtual-machine-selectiondag-selection-directed-acyclic-graph-instruction-selection&quot;&gt;LLVM (Low Level Virtual Machine) SelectionDAG (Selection Directed Acyclic Graph) instruction selection&lt;a class=&quot;zola-anchor&quot; href=&quot;#llvm-low-level-virtual-machine-selectiondag-selection-directed-acyclic-graph-instruction-selection&quot; aria-label=&quot;Anchor link for: llvm-low-level-virtual-machine-selectiondag-selection-directed-acyclic-graph-instruction-selection&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Declarative &lt;code&gt;Pat&amp;lt;&amp;gt;&lt;&#x2F;code&gt; patterns (TableGen) match target‑independent DAGs (Directed Acyclic Graphs) and rewrite to machine instructions.&lt;&#x2F;li&gt;
&lt;li&gt;Pros: declarative, identity‑aware, compact state machine, type‑checked, extensible with custom C++.&lt;&#x2F;li&gt;
&lt;li&gt;Cons: narrowly scoped to &lt;strong&gt;instruction selection&lt;&#x2F;strong&gt;, requires rebuild to extend, limited diagnostics, SelectionDAG (Selection Directed Acyclic Graph) constraints (e.g., multi‑result pain), accumulated tech debt.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;equality-saturation-e-graphs-why-it-matters&quot;&gt;Equality saturation (e‑graphs) — why it matters&lt;a class=&quot;zola-anchor&quot; href=&quot;#equality-saturation-e-graphs-why-it-matters&quot; aria-label=&quot;Anchor link for: equality-saturation-e-graphs-why-it-matters&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Solves the “optimizing too early” problem: keep &lt;strong&gt;all&lt;&#x2F;strong&gt; equivalent forms; pick best later via a cost model.&lt;&#x2F;li&gt;
&lt;li&gt;Trade‑off: search‑space growth; prototypes exist around MLIR (Multi-Level Intermediate Representation), but not core yet.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;goals-of-mlir-multi-level-intermediate-representation-generic-dag-directed-acyclic-graph-rewriter&quot;&gt;Goals of MLIR (Multi-Level Intermediate Representation) generic DAG (Directed Acyclic Graph) rewriter&lt;a class=&quot;zola-anchor&quot; href=&quot;#goals-of-mlir-multi-level-intermediate-representation-generic-dag-directed-acyclic-graph-rewriter&quot; aria-label=&quot;Anchor link for: goals-of-mlir-multi-level-intermediate-representation-generic-dag-directed-acyclic-graph-rewriter&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Support &lt;strong&gt;1→N&lt;&#x2F;strong&gt;, &lt;strong&gt;M→1&lt;&#x2F;strong&gt;, &lt;strong&gt;M→N&lt;&#x2F;strong&gt; with &lt;strong&gt;benefits&lt;&#x2F;strong&gt;; infra picks best local match.&lt;&#x2F;li&gt;
&lt;li&gt;Separate (1) best pattern at a root, (2) whole‑graph rewrite strategy, (3) pattern definitions.&lt;&#x2F;li&gt;
&lt;li&gt;Enable iterative rewrites with different client trade‑offs.&lt;&#x2F;li&gt;
&lt;li&gt;Make patterns easy, safe, and resilient: simple APIs (Application Programming Interfaces), clean legality separation, strong provenance and diagnostics.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;non-goals-limits&quot;&gt;Non‑goals &#x2F; limits&lt;a class=&quot;zola-anchor&quot; href=&quot;#non-goals-limits&quot; aria-label=&quot;Anchor link for: non-goals-limits&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Not for global data‑flow problems (e.g., CSE (Common Subexpression Elimination), SCCP (Sparse Conditional Constant Propagation)).&lt;&#x2F;li&gt;
&lt;li&gt;Limited to DAGs (Directed Acyclic Graphs); won’t see through cycles &#x2F; across block arguments.&lt;&#x2F;li&gt;
&lt;li&gt;Pattern “benefits” are magic numbers; each application interprets them.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;minimal-runnable-mlir-multi-level-intermediate-representation-snippets&quot;&gt;Minimal, runnable MLIR (Multi-Level Intermediate Representation) snippets&lt;a class=&quot;zola-anchor&quot; href=&quot;#minimal-runnable-mlir-multi-level-intermediate-representation-snippets&quot; aria-label=&quot;Anchor link for: minimal-runnable-mlir-multi-level-intermediate-representation-snippets&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;A) CSE (Common Subexpression Elimination)&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;mlir&quot; class=&quot;language-mlir z-code&quot;&gt;&lt;code class=&quot;language-mlir&quot; data-lang=&quot;mlir&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;module {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  func.func @cse(%a: i32, %b: i32) -&amp;gt; i32 {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    %0 = arith.addi %a, %b : i32 loc(&amp;quot;A&amp;quot;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    %1 = arith.addi %a, %b : i32 loc(&amp;quot;B&amp;quot;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    %2 = arith.muli %0, %1 : i32
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    return %2 : i32
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Run: &lt;code&gt;mlir-opt input.mlir -cse&lt;&#x2F;code&gt;
Result: &lt;code&gt;%1&lt;&#x2F;code&gt; removed; &lt;code&gt;%2 = arith.muli %0, %0&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;B) LICM (Loop‑Invariant Code Motion)&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;mlir&quot; class=&quot;language-mlir z-code&quot;&gt;&lt;code class=&quot;language-mlir&quot; data-lang=&quot;mlir&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;module {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  func.func @licm(%A: i32, %n: index) -&amp;gt; i32 {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    %c0  = arith.constant 0 : index
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    %c1  = arith.constant 1 : index
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    %z0  = arith.constant 0 : i32
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    %res = scf.for %i = %c0 to %n step %c1 iter_args(%acc = %z0) -&amp;gt; (i32) {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;      %two   = arith.constant 2 : i32
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;      %scale = arith.muli %A, %two : i32
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;      %acc1  = arith.addi %acc, %scale : i32
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;      scf.yield %acc1 : i32
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;    return %res : i32
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  }
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;}
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Run: &lt;code&gt;mlir-opt input.mlir -loop-invariant-code-motion&lt;&#x2F;code&gt;
Effect: &lt;code&gt;%two&lt;&#x2F;code&gt; and &lt;code&gt;%scale&lt;&#x2F;code&gt; are hoisted to the preheader; loop body shrinks.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;practical-takeaways&quot;&gt;Practical takeaways&lt;a class=&quot;zola-anchor&quot; href=&quot;#practical-takeaways&quot; aria-label=&quot;Anchor link for: practical-takeaways&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Use the &lt;strong&gt;canonicalizer&lt;&#x2F;strong&gt; + &lt;strong&gt;CSE (Common Subexpression Elimination)&lt;&#x2F;strong&gt; early to normalize IR (Intermediate Representation); then apply richer &lt;strong&gt;RewritePattern&lt;&#x2F;strong&gt;s.&lt;&#x2F;li&gt;
&lt;li&gt;Prefer &lt;strong&gt;declarative patterns&lt;&#x2F;strong&gt; (DRR (Declarative Rewrite Rules), PDL&#x2F;PDLL (Pattern Description Language &#x2F; Pattern Description Language frontend)) over ad‑hoc C++ when possible.&lt;&#x2F;li&gt;
&lt;li&gt;Be mindful of &lt;strong&gt;dominance&lt;&#x2F;strong&gt;, &lt;strong&gt;legality&lt;&#x2F;strong&gt;, and &lt;strong&gt;register pressure&lt;&#x2F;strong&gt; when hoisting&#x2F;fusing.&lt;&#x2F;li&gt;
&lt;li&gt;Consider &lt;strong&gt;equality saturation&lt;&#x2F;strong&gt; for domains where early canonicalization can kill opportunities.&lt;&#x2F;li&gt;
&lt;li&gt;Remember limits: this infra isn’t a substitute for &lt;strong&gt;CFG (Control‑Flow Graph)&lt;&#x2F;strong&gt;-wide analyses like &lt;strong&gt;GVN (Global Value Numbering)&lt;&#x2F;strong&gt; or &lt;strong&gt;SCCP (Sparse Conditional Constant Propagation)&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;&lt;em&gt;Prepared as a quick post‑able note; feel free to copy&#x2F;paste to your site as is.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>Φ-nodes, SSI, and MLIR Block Arguments</title>
		<published>2025-10-02T00:00:00+00:00</published>
		<updated>2025-10-02T00:00:00+00:00</updated>
		<link rel="alternate" type="text/html" href="https://josephbak.github.io/notes/phi-nodes-ssi-mlir/"/>
		<id>https://josephbak.github.io/notes/phi-nodes-ssi-mlir/</id>
    
		<content type="html" xml:base="https://josephbak.github.io/notes/phi-nodes-ssi-mlir/">&lt;!-- # Φ-nodes, SSI, and MLIR Block Arguments --&gt;
&lt;h2 id=&quot;1-ph-nodes-ssa-basics&quot;&gt;1. Φ-nodes (SSA basics)&lt;a class=&quot;zola-anchor&quot; href=&quot;#1-ph-nodes-ssa-basics&quot; aria-label=&quot;Anchor link for: 1-ph-nodes-ssa-basics&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SSA (Static Single Assignment):&lt;&#x2F;strong&gt; each variable assigned once.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Problem:&lt;&#x2F;strong&gt; at control-flow merges, multiple reaching definitions exist.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Solution:&lt;&#x2F;strong&gt; φ-node merges values depending on predecessor.&lt;br &#x2F;&gt;
Example in LLVM IR:&lt;pre data-lang=&quot;llvm&quot; class=&quot;language-llvm z-code&quot;&gt;&lt;code class=&quot;language-llvm&quot; data-lang=&quot;llvm&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;merge:
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  %x = phi i32 [1, %then], [2, %else]
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Limitation: φ handles &lt;em&gt;merges only&lt;&#x2F;em&gt;, not branch-specific refinements.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;2-mlir-block-arguments&quot;&gt;2. MLIR Block Arguments&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-mlir-block-arguments&quot; aria-label=&quot;Anchor link for: 2-mlir-block-arguments&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;MLIR treats &lt;strong&gt;basic blocks like functions&lt;&#x2F;strong&gt;:
&lt;ul&gt;
&lt;li&gt;Blocks can declare arguments.&lt;&#x2F;li&gt;
&lt;li&gt;Terminators (br, cond_br) pass values to successors.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Block arguments replace φ-nodes&lt;&#x2F;strong&gt;.&lt;br &#x2F;&gt;
Example:&lt;pre data-lang=&quot;mlir&quot; class=&quot;language-mlir z-code&quot;&gt;&lt;code class=&quot;language-mlir&quot; data-lang=&quot;mlir&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;^merge(%x: i32):
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;  %y = addi %x, %c3
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Advantages (from MLIR Rationale):
&lt;ol&gt;
&lt;li&gt;No “all φ at block top” special case.&lt;&#x2F;li&gt;
&lt;li&gt;Function args = block args (unified model).&lt;&#x2F;li&gt;
&lt;li&gt;No “atomic φ-bundle” problems (lost-copy issues).&lt;&#x2F;li&gt;
&lt;li&gt;Scales better for many predecessors.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;3-ssi-static-single-information&quot;&gt;3. SSI (Static Single Information)&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-ssi-static-single-information&quot; aria-label=&quot;Anchor link for: 3-ssi-static-single-information&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Extension of SSA: adds &lt;strong&gt;σ-nodes at splits&lt;&#x2F;strong&gt; (dual of φ at joins).&lt;&#x2F;li&gt;
&lt;li&gt;Purpose: propagate &lt;em&gt;branch-sensitive facts&lt;&#x2F;em&gt;.
&lt;ul&gt;
&lt;li&gt;Example: &lt;code&gt;if (x == 0)&lt;&#x2F;code&gt; ⇒ σ splits into &lt;code&gt;x0&lt;&#x2F;code&gt; (then) and &lt;code&gt;x_not0&lt;&#x2F;code&gt; (else).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Placement:&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;φ-nodes placed using dominance frontier DF(·).&lt;&#x2F;li&gt;
&lt;li&gt;σ-nodes placed using reverse dominance frontier RDF(·).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;Benefits: precise predicated and backward dataflow analyses.&lt;&#x2F;li&gt;
&lt;li&gt;Sources: Ananian (1999&#x2F;2001), Singer (2002).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;4-why-mlir-doesn-t-need-ph&quot;&gt;4. Why MLIR Doesn’t Need φ&lt;a class=&quot;zola-anchor&quot; href=&quot;#4-why-mlir-doesn-t-need-ph&quot; aria-label=&quot;Anchor link for: 4-why-mlir-doesn-t-need-ph&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Block arguments are a strict superset of φ-nodes&lt;&#x2F;strong&gt; (Chris Lattner).&lt;&#x2F;li&gt;
&lt;li&gt;Block args handle both:
&lt;ul&gt;
&lt;li&gt;φ-like merges at joins.&lt;&#x2F;li&gt;
&lt;li&gt;σ-like refinements at branches (by passing renamed arguments).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;This makes MLIR’s design &lt;strong&gt;functional SSA&lt;&#x2F;strong&gt;: branches apply values to blocks like function calls.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;5-counterarguments-responses&quot;&gt;5. Counterarguments &amp;amp; Responses&lt;a class=&quot;zola-anchor&quot; href=&quot;#5-counterarguments-responses&quot; aria-label=&quot;Anchor link for: 5-counterarguments-responses&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Criticism (HN):&lt;&#x2F;strong&gt; “Block args are just syntax for φ.”&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Response:&lt;&#x2F;strong&gt; With σ-like behavior (branch-local refinements), block args are more general than φ.
&lt;ul&gt;
&lt;li&gt;Example: conditions like &lt;code&gt;x==0&lt;&#x2F;code&gt; vs &lt;code&gt;x!=0&lt;&#x2F;code&gt; are explicit in MLIR args.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;6-performance-cost-considerations&quot;&gt;6. Performance &#x2F; Cost Considerations&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-performance-cost-considerations&quot; aria-label=&quot;Anchor link for: 6-performance-cost-considerations&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SSA out-of-form:&lt;&#x2F;strong&gt; eliminating φ requires &lt;strong&gt;parallel copy resolution&lt;&#x2F;strong&gt; (lost-copy, swap problems).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;MLIR advantage:&lt;&#x2F;strong&gt; explicit argument passing avoids “atomic φ-bundles.”&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;SSI&#x2F;Singer:&lt;&#x2F;strong&gt; more nodes, but pruned forms are efficient; optimistic algorithms exist.&lt;&#x2F;li&gt;
&lt;li&gt;Lowering MLIR → LLVM IR: block args are reconstructed as φ-nodes for backends.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;7-comparisons-to-other-ir-designs&quot;&gt;7. Comparisons to Other IR Designs&lt;a class=&quot;zola-anchor&quot; href=&quot;#7-comparisons-to-other-ir-designs&quot; aria-label=&quot;Anchor link for: 7-comparisons-to-other-ir-designs&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;CPS (Continuation-Passing Style):&lt;&#x2F;strong&gt; blocks-as-functions, more explicit than MLIR.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Region-based IRs (Sea-of-Nodes):&lt;&#x2F;strong&gt; merges are implicit via dataflow edges.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Predicate&#x2F;Gated SSA (GSA, PSSA):&lt;&#x2F;strong&gt; encode conditions explicitly; similar motivation to SSI.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;MLIR position:&lt;&#x2F;strong&gt; middle ground — explicit, compositional, generalizes φ and σ.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;8-what-to-add-for-completeness&quot;&gt;8. What to Add for Completeness&lt;a class=&quot;zola-anchor&quot; href=&quot;#8-what-to-add-for-completeness&quot; aria-label=&quot;Anchor link for: 8-what-to-add-for-completeness&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;CGO slides &#x2F; DevMtg talks (Lattner):&lt;&#x2F;strong&gt; design tradeoffs and heuristics.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;MLIR Rationale &amp;amp; LangRef:&lt;&#x2F;strong&gt; official explanation + examples.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Formal definitions:&lt;&#x2F;strong&gt; φ placement (DF), σ placement (RDF).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Counterexamples:&lt;&#x2F;strong&gt; branch-specific renamings that φ cannot encode.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Implementation cost:&lt;&#x2F;strong&gt; Singer’s node counts, SSA destruction papers (Boissinot 2009, Pereira 2009).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Lowering reality:&lt;&#x2F;strong&gt; LLVM and SPIR-V still need φ; MLIR reconstructs them.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Other IRs:&lt;&#x2F;strong&gt; compare to CPS, region&#x2F;dataflow IRs.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;9-reading-list&quot;&gt;9. Reading List&lt;a class=&quot;zola-anchor&quot; href=&quot;#9-reading-list&quot; aria-label=&quot;Anchor link for: 9-reading-list&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SSA core:&lt;&#x2F;strong&gt; Cytron et al. (1991) &lt;em&gt;Efficiently Computing SSA&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;SSI:&lt;&#x2F;strong&gt; Ananian (1999&#x2F;2001), Singer (2002) &lt;em&gt;Efficiently Computing SSI&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Out-of-SSA:&lt;&#x2F;strong&gt; Boissinot et al. (2009), Pereira &amp;amp; Palsberg (2009).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;MLIR docs:&lt;&#x2F;strong&gt;
&lt;ul&gt;
&lt;li&gt;LangRef → Blocks&lt;&#x2F;li&gt;
&lt;li&gt;Rationale → Block Arguments vs PHI nodes&lt;&#x2F;li&gt;
&lt;li&gt;LLVM dialect → PHI Nodes and Block Args&lt;&#x2F;li&gt;
&lt;li&gt;SPIR-V dialect → Block args for Phi&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Design context:&lt;&#x2F;strong&gt; Nikita Popov, &lt;em&gt;Design Issues in LLVM IR&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Talks:&lt;&#x2F;strong&gt; Lattner&#x2F;Shpeisman CGO &amp;amp; LLVM Dev Mtg slides.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;✅ &lt;strong&gt;Key Takeaway:&lt;&#x2F;strong&gt;&lt;br &#x2F;&gt;
MLIR’s block arguments &lt;strong&gt;subsume φ-nodes and σ-nodes&lt;&#x2F;strong&gt; in a clean, function-like model. They make SSA transformations easier, interop with existing IRs via lowering, and position MLIR as a generalization of SSA forms like SSI, GSA, PSSA.&lt;&#x2F;p&gt;
</content>
	</entry>
	<entry xml:lang="en">
		<title>From Use–Def to Preimage: Fusing Structured Ops in MLIR</title>
		<published>2025-10-01T00:00:00+00:00</published>
		<updated>2025-10-01T00:00:00+00:00</updated>
		<link rel="alternate" type="text/html" href="https://josephbak.github.io/notes/mlir-use-def-indexing-maps-preimage-inline-katex/"/>
		<id>https://josephbak.github.io/notes/mlir-use-def-indexing-maps-preimage-inline-katex/</id>
    
		<content type="html" xml:base="https://josephbak.github.io/notes/mlir-use-def-indexing-maps-preimage-inline-katex/">&lt;!-- KaTeX includes (inline; requires markdown.render_unsafe = true) --&gt;
&lt;link rel=&quot;stylesheet&quot; href=&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.16.10&#x2F;dist&#x2F;katex.min.css&quot;&gt;
&lt;script defer src=&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.16.10&#x2F;dist&#x2F;katex.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script defer src=&quot;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;katex@0.16.10&#x2F;dist&#x2F;contrib&#x2F;auto-render.min.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;script&gt;
 document.addEventListener(&quot;DOMContentLoaded&quot;, function() {
 renderMathInElement(document.body, {
 delimiters: [
 {left: &quot;$$&quot;, right: &quot;$$&quot;, display: true},
 {left: &quot;\\[&quot;, right: &quot;\\]&quot;, display: true},
 {left: &quot;$&quot;, right: &quot;$&quot;, display: false},
 {left: &quot;\\(&quot;, right: &quot;\\)&quot;, display: false}
 ],
 throwOnError: false
 });
 });
&lt;&#x2F;script&gt;
&lt;p&gt;&lt;em&gt;A short, practical note for future-me about the core ideas behind producer&#x2F;consumer fusion in MLIR’s structured world.&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;tl-dr&quot;&gt;TL;DR&lt;a class=&quot;zola-anchor&quot; href=&quot;#tl-dr&quot; aria-label=&quot;Anchor link for: tl-dr&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Use-def:&lt;&#x2F;strong&gt; follow SSA edges from a consumer tile back to the op that defines its input.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Indexing map:&lt;&#x2F;strong&gt; for each operand, an affine map $f:\mathbb{Z}^n\to\mathbb{Z}^r$ from loop indices to subscripts.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Invert vs preimage:&lt;&#x2F;strong&gt; only invertible if $f$ is unimodular&#x2F;permutation; in general compute the &lt;strong&gt;preimage&lt;&#x2F;strong&gt; $ f^{-1}(S) = \lbrace \mathbf{i}\mid f(\mathbf{i})\in S \rbrace $.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Fusion across mismatched spaces:&lt;&#x2F;strong&gt; pull back the consumer tile through the producer’s output map to compute &lt;strong&gt;exactly&lt;&#x2F;strong&gt; the producer iterations you need &lt;em&gt;in place&lt;&#x2F;em&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Rematerialization:&lt;&#x2F;strong&gt; deliberate recomputation of cheap producers per tile to kill memory traffic.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;1-use-def-in-one-picture&quot;&gt;1) Use-Def in one picture&lt;a class=&quot;zola-anchor&quot; href=&quot;#1-use-def-in-one-picture&quot; aria-label=&quot;Anchor link for: 1-use-def-in-one-picture&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;pre class=&quot;z-code&quot;&gt;&lt;code&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;%Y = linalg.matmul ... &#x2F;&#x2F; def(%Y) = matmul
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;%Z = linalg.generic ins(%Y) ... &#x2F;&#x2F; %Y is used here → consumer
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;matmul ──defines──▶ generic &#x2F;&#x2F; def→use
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;generic ──uses──────▶ matmul &#x2F;&#x2F; use→def (reverse walk for fusion)
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;strong&gt;Quick defs (SSA&#x2F;MLIR):&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;SSA value&lt;&#x2F;strong&gt;: defined once, used many times.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;def(v)&lt;&#x2F;strong&gt;: the op (or block arg) that defines &lt;code&gt;v&lt;&#x2F;code&gt;.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;uses(v)&lt;&#x2F;strong&gt;: the ops that consume &lt;code&gt;v&lt;&#x2F;code&gt; as an operand.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;def→use&lt;&#x2F;strong&gt;: from a value’s def to all its consumers (“who reads what I produce?”).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;use→def&lt;&#x2F;strong&gt;: from a consumer operand back to the op that defined it (what we walk for fusion).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;producer&#x2F;consumer&lt;&#x2F;strong&gt;: if &lt;code&gt;P&lt;&#x2F;code&gt; defines &lt;code&gt;%x&lt;&#x2F;code&gt; and &lt;code&gt;C&lt;&#x2F;code&gt; takes &lt;code&gt;%x&lt;&#x2F;code&gt;, then &lt;code&gt;P&lt;&#x2F;code&gt; is &lt;code&gt;%x&lt;&#x2F;code&gt;’s &lt;strong&gt;producer&lt;&#x2F;strong&gt;, &lt;code&gt;C&lt;&#x2F;code&gt; its &lt;strong&gt;consumer&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;We start from a &lt;strong&gt;consumer tile&lt;&#x2F;strong&gt; (a 2‑D slice of &lt;code&gt;%Z&lt;&#x2F;code&gt;) and walk &lt;strong&gt;use→def&lt;&#x2F;strong&gt; to find the &lt;strong&gt;producer&lt;&#x2F;strong&gt; (&lt;code&gt;%Y&lt;&#x2F;code&gt; from matmul) to potentially fuse.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;2-indexing-maps-formal-and-concrete&quot;&gt;2) Indexing maps (formal and concrete)&lt;a class=&quot;zola-anchor&quot; href=&quot;#2-indexing-maps-formal-and-concrete&quot; aria-label=&quot;Anchor link for: 2-indexing-maps-formal-and-concrete&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;For a structured op with iteration indices $\mathbf{i}=(i_0,\ldots,i_{n-1})$, each operand gets an affine map
$$
f_{\text{opnd}}:\mathbb{Z}^n\to\mathbb{Z}^r,\qquad \mathbf{i}\mapsto \text{subscripts}
$$&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Notation.&lt;&#x2F;strong&gt; The subscript in $f_{\text{opnd}}$ means &lt;em&gt;per-operand&lt;&#x2F;em&gt; indexing map. For a given op you have one map per operand:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Inputs: $f_A, f_B, \ldots$ (often referred to generically as $f_{\text{in}}$ for an input).&lt;&#x2F;li&gt;
&lt;li&gt;Output&#x2F;result: $f_{\text{out}}$.
These maps live over the op&#x27;s iterator space and tell &lt;strong&gt;which element&lt;&#x2F;strong&gt; of each operand is touched at a point.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;that answers: &lt;em&gt;“At this loop point, which element of this tensor&#x2F;buffer do I touch?”&lt;&#x2F;em&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Matmul&lt;&#x2F;strong&gt; (iterators $(i,j,k)$; $i,j$ parallel, $k$ reduction):&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;$f_A(i,j,k)=(i,k)$&lt;&#x2F;li&gt;
&lt;li&gt;$f_B(i,j,k)=(k,j)$&lt;&#x2F;li&gt;
&lt;li&gt;$f_C(i,j,k)=(i,j)$ ← output map&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Elementwise same-shape&lt;&#x2F;strong&gt; (iterators $(i,j)$):&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;for each input, $f_{\text{in}}(i,j)=(i,j)$; for the output, $f_{\text{out}}(i,j)=(i,j)$&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Broadcasts, transposes, striding, dilations are all just different affine maps.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;3-invert-vs-preimage-the-actual-thing-you-need&quot;&gt;3) “Invert” vs &lt;strong&gt;preimage&lt;&#x2F;strong&gt; (the actual thing you need)&lt;a class=&quot;zola-anchor&quot; href=&quot;#3-invert-vs-preimage-the-actual-thing-you-need&quot; aria-label=&quot;Anchor link for: 3-invert-vs-preimage-the-actual-thing-you-need&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;Given a consumer &lt;strong&gt;tile&lt;&#x2F;strong&gt; $S\subseteq\mathbb{Z}^r$ in output index space and the producer’s output map $f_{\text{out}}:\mathbb{Z}^n\to\mathbb{Z}^r$, what you want is the &lt;strong&gt;preimage&lt;&#x2F;strong&gt;:&lt;&#x2F;p&gt;
&lt;p&gt;$$
T = f_{\text{out}}^{-1}(S) = \lbrace \mathbf{i}\in\mathbb{Z}^n \mid f_{\text{out}}(\mathbf{i}) \in S \rbrace.
$$&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;If $f_{\text{out}}$ is &lt;strong&gt;unimodular&#x2F;permutation&lt;&#x2F;strong&gt; → there is a true algebraic inverse (nice!).&lt;&#x2F;li&gt;
&lt;li&gt;If it &lt;strong&gt;drops&lt;&#x2F;strong&gt; dims (projection&#x2F;reduction), &lt;strong&gt;strides&lt;&#x2F;strong&gt;, or &lt;strong&gt;dilates&lt;&#x2F;strong&gt; → no inverse; &lt;strong&gt;preimage&lt;&#x2F;strong&gt; still exists and is what we use.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Examples&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Permutation:&lt;&#x2F;strong&gt; $f(i,j)=(j,i)$. For a rectangular tile $S=I\times J$, $f^{-1}(S)=J\times I$.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Reduction:&lt;&#x2F;strong&gt; matmul $f(i,j,k)=(i,j)$. For tile $S=I\times J$, $f^{-1}(S)=I\times J\times [0..K)$.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Stride:&lt;&#x2F;strong&gt; $f(i,j)=(2i,j)$. Preimage adds congruence: $ \lbrace (i,j)\mid 2i\in I,\ j\in J \rbrace $ (appears as strided slices).&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Once you have $T$ (the subset of producer iterations), the &lt;strong&gt;input slices&lt;&#x2F;strong&gt; you need are just the &lt;strong&gt;images&lt;&#x2F;strong&gt; $g_A(T), g_B(T),\ldots$ under each input map $g$.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;4-fusion-across-mismatched-iteration-spaces-recipe&quot;&gt;4) Fusion across mismatched iteration spaces (recipe)&lt;a class=&quot;zola-anchor&quot; href=&quot;#4-fusion-across-mismatched-iteration-spaces-recipe&quot; aria-label=&quot;Anchor link for: 4-fusion-across-mismatched-iteration-spaces-recipe&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Tile the consumer&lt;&#x2F;strong&gt; over its parallel dims: choose $S\subseteq\mathbb{Z}^r$.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Use→def&lt;&#x2F;strong&gt; to find the producer of the consumer’s operand.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Pull back&lt;&#x2F;strong&gt; the tile: $T=f_{\text{out}}^{-1}(S)$ in the producer’s loop space.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Extract input slices&lt;&#x2F;strong&gt; using each input map’s image of $T$.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Run the producer on $T$ &lt;em&gt;inside&lt;&#x2F;em&gt; the consumer tile&lt;&#x2F;strong&gt;; feed the partial result directly; no giant temporaries.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;strong&gt;Mini numeric sanity check&lt;&#x2F;strong&gt;
Let $M=4,\ N=6,\ K=3$. Tile size $(T_m,T_n)=(2,2)$ at offset $(i_0,j_0)=(2,4)$.&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Consumer tile $S=\lbrace i\in\lbrace 2,3 \rbrace,\ j\in\lbrace 4,5 \rbrace \rbrace$.&lt;&#x2F;li&gt;
&lt;li&gt;Matmul output map $f(i,j,k)=(i,j)$ ⇒
$T=\lbrace (i,j,k)\mid i\in\lbrace 2,3 \rbrace,\ j\in\lbrace 4,5 \rbrace,\ k\in\lbrace 0,1,2 \rbrace \rbrace$.&lt;&#x2F;li&gt;
&lt;li&gt;Needed slices:&lt;&#x2F;li&gt;
&lt;li&gt;$A(i,k)$ ⇒ rows $\lbrace 2,3 \rbrace$ and all $k$ ⇒ $A_{\text{slice}} : 2 \times 3$.&lt;&#x2F;li&gt;
&lt;li&gt;$B(k,j)$ ⇒ all $k$ and cols $\lbrace 4,5 \rbrace$ ⇒ $B_{\text{slice}} : 3 \times 2$.&lt;&#x2F;li&gt;
&lt;li&gt;Compute a $2\times 2$ partial, then apply the elementwise op and insert.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;5-rematerialization-when-why&quot;&gt;5) Rematerialization (when&#x2F;why)&lt;a class=&quot;zola-anchor&quot; href=&quot;#5-rematerialization-when-why&quot; aria-label=&quot;Anchor link for: 5-rematerialization-when-why&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;We call it &lt;strong&gt;rematerialization&lt;&#x2F;strong&gt; when we recompute values per tile instead of storing a big temporary in memory.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;Typical cases&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Upstream elementwise producers: $L=\mathrm{relu}(L_0)$, $R=\exp(R_0)$.
If you fuse them into each tile, elements like $L[i,k]$ are recomputed &lt;strong&gt;per $j$-tile&lt;&#x2F;strong&gt;; duplication factor $\approx N&#x2F;T_n$. Similarly $R[k,j]$ across $i$-tiles; factor $\approx M&#x2F;T_m$.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;
&lt;p&gt;Same producer result used by multiple consumers → recompute the same producer tile in each consumer’s loop.&lt;&#x2F;p&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;&lt;strong&gt;Why it can win:&lt;&#x2F;strong&gt; modern kernels are memory-bound. Extra flops are cheap; avoiding DRAM traffic and improving locality is often a net gain.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;strong&gt;When to avoid:&lt;&#x2F;strong&gt; producer is heavy and reused many times; or fusion hides &lt;code&gt;vector.contract&lt;&#x2F;code&gt;&#x2F;MMA patterns and spikes register pressure.&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;6-practical-heuristics&quot;&gt;6) Practical heuristics&lt;a class=&quot;zola-anchor&quot; href=&quot;#6-practical-heuristics&quot; aria-label=&quot;Anchor link for: 6-practical-heuristics&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Tile parallel dims first&lt;&#x2F;strong&gt;; shape inner kernels for cache&#x2F;SMEM; keep unit-stride for vector lanes.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Fuse cheap, pure producers&#x2F;epilogues&lt;&#x2F;strong&gt;; prefer rematerialization over big temporaries.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Keep contractions recognizable&lt;&#x2F;strong&gt; so they lower to &lt;code&gt;vector.contract&lt;&#x2F;code&gt;&#x2F;tensor cores before heavy epilogues.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Measure pressure&lt;&#x2F;strong&gt;: spills on CPU; regs&#x2F;thread &amp;amp; occupancy on GPU.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;7-glossary-fast&quot;&gt;7) Glossary (fast)&lt;a class=&quot;zola-anchor&quot; href=&quot;#7-glossary-fast&quot; aria-label=&quot;Anchor link for: 7-glossary-fast&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Use-def:&lt;&#x2F;strong&gt; SSA graph edges from values to their users&#x2F;definers.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Indexing map:&lt;&#x2F;strong&gt; affine map from loop indices to subscripts ($f:\mathbb{Z}^n\to\mathbb{Z}^r$).&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Preimage:&lt;&#x2F;strong&gt; $ f^{-1}(S) = \lbrace \mathbf{i} \mid f(\mathbf{i})\in S \rbrace $; what you compute to fuse a producer tile.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Rematerialization:&lt;&#x2F;strong&gt; recomputing values per tile to avoid storing&#x2F;reloading them from memory.&lt;&#x2F;li&gt;
&lt;li&gt;&lt;strong&gt;Materialize loops:&lt;&#x2F;strong&gt; turn implicit iteration into &lt;code&gt;scf.for&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;scf.forall&lt;&#x2F;code&gt; + (tensor) slices.&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;hr &#x2F;&gt;
&lt;h2 id=&quot;8-tiny-mlir-snippet-to-anchor-the-math&quot;&gt;8) Tiny MLIR snippet to anchor the math&lt;a class=&quot;zola-anchor&quot; href=&quot;#8-tiny-mlir-snippet-to-anchor-the-math&quot; aria-label=&quot;Anchor link for: 8-tiny-mlir-snippet-to-anchor-the-math&quot; style=&quot;visibility: hidden;&quot;&gt;&lt;&#x2F;a&gt;
&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;strong&gt;Matmul tile inside consumer tile (conceptual):&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;mlir&quot; class=&quot;language-mlir z-code&quot;&gt;&lt;code class=&quot;language-mlir&quot; data-lang=&quot;mlir&quot;&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;%lhs_slice = tensor.extract_slice %L[%i0, 0] [Tm, K] [1,1]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;%rhs_slice = tensor.extract_slice %R[0, %j0] [K, Tn] [1,1]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;%res_slice = tensor.extract_slice %Res[%i0, %j0][Tm, Tn] [1,1]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;%partial = linalg.generic {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; indexing_maps = [ (i,j,k)-&amp;gt;(i,k), (i,j,k)-&amp;gt;(k,j), (i,j,k)-&amp;gt;(i,j) ],
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; iterator_types = [&amp;quot;parallel&amp;quot;,&amp;quot;parallel&amp;quot;,&amp;quot;reduction&amp;quot;]
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;} ins(%lhs_slice, %rhs_slice : tensor&amp;lt;Tm x Kxf32&amp;gt;, tensor&amp;lt;K x Tnxf32&amp;gt;)
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; outs(%res_slice : tensor&amp;lt;Tm x Tnxf32&amp;gt;) {
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;^bb0(%a: f32, %b: f32, %acc: f32):
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; %p = arith.mulf %a, %b : f32
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; %s = arith.addf %acc, %p : f32
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt; linalg.yield %s : f32
&lt;&#x2F;span&gt;&lt;span class=&quot;z-text z-plain&quot;&gt;} -&amp;gt; tensor&amp;lt;Tm x Tnxf32&amp;gt;
&lt;&#x2F;span&gt;&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</content>
	</entry>
</feed>
